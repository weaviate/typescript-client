// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.176.0
//   protoc               v3.19.1
// source: v1/aggregate.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal.js";
import { BooleanArray, Filters, GeoCoordinatesFilter, IntArray, NumberArray, TextArray } from "./base.js";
import {
  Hybrid,
  NearAudioSearch,
  NearDepthSearch,
  NearImageSearch,
  NearIMUSearch,
  NearObject,
  NearTextSearch,
  NearThermalSearch,
  NearVector,
  NearVideoSearch,
} from "./base_search.js";

export const protobufPackage = "weaviate.v1";

export interface AggregateRequest {
  /** required */
  collection: string;
  /** parameters */
  tenant: string;
  /** what is returned */
  objectsCount: boolean;
  aggregations: AggregateRequest_Aggregation[];
  /** affects aggregation results */
  objectLimit?: number | undefined;
  groupBy?: AggregateRequest_GroupBy | undefined;
  limit?:
    | number
    | undefined;
  /** matches/searches for objects */
  filters?: Filters | undefined;
  hybrid?: Hybrid | undefined;
  nearVector?: NearVector | undefined;
  nearObject?: NearObject | undefined;
  nearText?: NearTextSearch | undefined;
  nearImage?: NearImageSearch | undefined;
  nearAudio?: NearAudioSearch | undefined;
  nearVideo?: NearVideoSearch | undefined;
  nearDepth?: NearDepthSearch | undefined;
  nearThermal?: NearThermalSearch | undefined;
  nearImu?: NearIMUSearch | undefined;
}

export interface AggregateRequest_Aggregation {
  property: string;
  int?: AggregateRequest_Aggregation_Integer | undefined;
  number?: AggregateRequest_Aggregation_Number | undefined;
  text?: AggregateRequest_Aggregation_Text | undefined;
  boolean?: AggregateRequest_Aggregation_Boolean | undefined;
  date?: AggregateRequest_Aggregation_DateMessage | undefined;
  reference?: AggregateRequest_Aggregation_Reference | undefined;
}

export interface AggregateRequest_Aggregation_Integer {
  count: boolean;
  type: boolean;
  sum: boolean;
  mean: boolean;
  mode: boolean;
  median: boolean;
  maximum: boolean;
  minimum: boolean;
}

export interface AggregateRequest_Aggregation_Number {
  count: boolean;
  type: boolean;
  sum: boolean;
  mean: boolean;
  mode: boolean;
  median: boolean;
  maximum: boolean;
  minimum: boolean;
}

export interface AggregateRequest_Aggregation_Text {
  count: boolean;
  type: boolean;
  topOccurences: boolean;
  topOccurencesLimit?: number | undefined;
}

export interface AggregateRequest_Aggregation_Boolean {
  count: boolean;
  type: boolean;
  totalTrue: boolean;
  totalFalse: boolean;
  percentageTrue: boolean;
  percentageFalse: boolean;
}

export interface AggregateRequest_Aggregation_DateMessage {
  count: boolean;
  type: boolean;
  median: boolean;
  mode: boolean;
  maximum: boolean;
  minimum: boolean;
}

export interface AggregateRequest_Aggregation_Reference {
  type: boolean;
  pointingTo: boolean;
}

export interface AggregateRequest_GroupBy {
  collection: string;
  property: string;
}

export interface AggregateReply {
  took: number;
  singleResult?: AggregateReply_Single | undefined;
  groupedResults?: AggregateReply_Grouped | undefined;
}

export interface AggregateReply_Aggregations {
  aggregations: AggregateReply_Aggregations_Aggregation[];
}

export interface AggregateReply_Aggregations_Aggregation {
  property: string;
  int?: AggregateReply_Aggregations_Aggregation_Integer | undefined;
  number?: AggregateReply_Aggregations_Aggregation_Number | undefined;
  text?: AggregateReply_Aggregations_Aggregation_Text | undefined;
  boolean?: AggregateReply_Aggregations_Aggregation_Boolean | undefined;
  date?: AggregateReply_Aggregations_Aggregation_DateMessage | undefined;
  reference?: AggregateReply_Aggregations_Aggregation_Reference | undefined;
}

export interface AggregateReply_Aggregations_Aggregation_Integer {
  count?: number | undefined;
  type?: string | undefined;
  mean?: number | undefined;
  median?: number | undefined;
  mode?: number | undefined;
  maximum?: number | undefined;
  minimum?: number | undefined;
  sum?: number | undefined;
}

export interface AggregateReply_Aggregations_Aggregation_Number {
  count?: number | undefined;
  type?: string | undefined;
  mean?: number | undefined;
  median?: number | undefined;
  mode?: number | undefined;
  maximum?: number | undefined;
  minimum?: number | undefined;
  sum?: number | undefined;
}

export interface AggregateReply_Aggregations_Aggregation_Text {
  count?: number | undefined;
  type?: string | undefined;
  topOccurences?: AggregateReply_Aggregations_Aggregation_Text_TopOccurrences | undefined;
}

export interface AggregateReply_Aggregations_Aggregation_Text_TopOccurrences {
  items: AggregateReply_Aggregations_Aggregation_Text_TopOccurrences_TopOccurrence[];
}

export interface AggregateReply_Aggregations_Aggregation_Text_TopOccurrences_TopOccurrence {
  value: string;
  occurs: number;
}

export interface AggregateReply_Aggregations_Aggregation_Boolean {
  count?: number | undefined;
  type?: string | undefined;
  totalTrue?: number | undefined;
  totalFalse?: number | undefined;
  percentageTrue?: number | undefined;
  percentageFalse?: number | undefined;
}

export interface AggregateReply_Aggregations_Aggregation_DateMessage {
  count?: number | undefined;
  type?: string | undefined;
  median?: string | undefined;
  mode?: string | undefined;
  maximum?: string | undefined;
  minimum?: string | undefined;
}

export interface AggregateReply_Aggregations_Aggregation_Reference {
  type?:
    | string
    | undefined;
  /** protolint:disable:next REPEATED_FIELD_NAMES_PLURALIZED */
  pointingTo: string[];
}

export interface AggregateReply_Single {
  objectsCount?: number | undefined;
  aggregations?: AggregateReply_Aggregations | undefined;
}

export interface AggregateReply_Group {
  objectsCount?: number | undefined;
  aggregations?: AggregateReply_Aggregations | undefined;
  groupedBy?: AggregateReply_Group_GroupedBy | undefined;
}

export interface AggregateReply_Group_GroupedBy {
  /** protolint:disable:next REPEATED_FIELD_NAMES_PLURALIZED */
  path: string[];
  text?: string | undefined;
  int?: number | undefined;
  boolean?: boolean | undefined;
  number?: number | undefined;
  texts?: TextArray | undefined;
  ints?: IntArray | undefined;
  booleans?: BooleanArray | undefined;
  numbers?: NumberArray | undefined;
  geo?: GeoCoordinatesFilter | undefined;
}

export interface AggregateReply_Grouped {
  groups: AggregateReply_Group[];
}

function createBaseAggregateRequest(): AggregateRequest {
  return {
    collection: "",
    tenant: "",
    objectsCount: false,
    aggregations: [],
    objectLimit: undefined,
    groupBy: undefined,
    limit: undefined,
    filters: undefined,
    hybrid: undefined,
    nearVector: undefined,
    nearObject: undefined,
    nearText: undefined,
    nearImage: undefined,
    nearAudio: undefined,
    nearVideo: undefined,
    nearDepth: undefined,
    nearThermal: undefined,
    nearImu: undefined,
  };
}

export const AggregateRequest = {
  encode(message: AggregateRequest, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.collection !== "") {
      writer.uint32(10).string(message.collection);
    }
    if (message.tenant !== "") {
      writer.uint32(82).string(message.tenant);
    }
    if (message.objectsCount !== false) {
      writer.uint32(160).bool(message.objectsCount);
    }
    for (const v of message.aggregations) {
      AggregateRequest_Aggregation.encode(v!, writer.uint32(170).fork()).ldelim();
    }
    if (message.objectLimit !== undefined) {
      writer.uint32(240).uint32(message.objectLimit);
    }
    if (message.groupBy !== undefined) {
      AggregateRequest_GroupBy.encode(message.groupBy, writer.uint32(250).fork()).ldelim();
    }
    if (message.limit !== undefined) {
      writer.uint32(256).uint32(message.limit);
    }
    if (message.filters !== undefined) {
      Filters.encode(message.filters, writer.uint32(322).fork()).ldelim();
    }
    if (message.hybrid !== undefined) {
      Hybrid.encode(message.hybrid, writer.uint32(330).fork()).ldelim();
    }
    if (message.nearVector !== undefined) {
      NearVector.encode(message.nearVector, writer.uint32(338).fork()).ldelim();
    }
    if (message.nearObject !== undefined) {
      NearObject.encode(message.nearObject, writer.uint32(346).fork()).ldelim();
    }
    if (message.nearText !== undefined) {
      NearTextSearch.encode(message.nearText, writer.uint32(354).fork()).ldelim();
    }
    if (message.nearImage !== undefined) {
      NearImageSearch.encode(message.nearImage, writer.uint32(362).fork()).ldelim();
    }
    if (message.nearAudio !== undefined) {
      NearAudioSearch.encode(message.nearAudio, writer.uint32(370).fork()).ldelim();
    }
    if (message.nearVideo !== undefined) {
      NearVideoSearch.encode(message.nearVideo, writer.uint32(378).fork()).ldelim();
    }
    if (message.nearDepth !== undefined) {
      NearDepthSearch.encode(message.nearDepth, writer.uint32(386).fork()).ldelim();
    }
    if (message.nearThermal !== undefined) {
      NearThermalSearch.encode(message.nearThermal, writer.uint32(394).fork()).ldelim();
    }
    if (message.nearImu !== undefined) {
      NearIMUSearch.encode(message.nearImu, writer.uint32(402).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AggregateRequest {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAggregateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.collection = reader.string();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.tenant = reader.string();
          continue;
        case 20:
          if (tag !== 160) {
            break;
          }

          message.objectsCount = reader.bool();
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.aggregations.push(AggregateRequest_Aggregation.decode(reader, reader.uint32()));
          continue;
        case 30:
          if (tag !== 240) {
            break;
          }

          message.objectLimit = reader.uint32();
          continue;
        case 31:
          if (tag !== 250) {
            break;
          }

          message.groupBy = AggregateRequest_GroupBy.decode(reader, reader.uint32());
          continue;
        case 32:
          if (tag !== 256) {
            break;
          }

          message.limit = reader.uint32();
          continue;
        case 40:
          if (tag !== 322) {
            break;
          }

          message.filters = Filters.decode(reader, reader.uint32());
          continue;
        case 41:
          if (tag !== 330) {
            break;
          }

          message.hybrid = Hybrid.decode(reader, reader.uint32());
          continue;
        case 42:
          if (tag !== 338) {
            break;
          }

          message.nearVector = NearVector.decode(reader, reader.uint32());
          continue;
        case 43:
          if (tag !== 346) {
            break;
          }

          message.nearObject = NearObject.decode(reader, reader.uint32());
          continue;
        case 44:
          if (tag !== 354) {
            break;
          }

          message.nearText = NearTextSearch.decode(reader, reader.uint32());
          continue;
        case 45:
          if (tag !== 362) {
            break;
          }

          message.nearImage = NearImageSearch.decode(reader, reader.uint32());
          continue;
        case 46:
          if (tag !== 370) {
            break;
          }

          message.nearAudio = NearAudioSearch.decode(reader, reader.uint32());
          continue;
        case 47:
          if (tag !== 378) {
            break;
          }

          message.nearVideo = NearVideoSearch.decode(reader, reader.uint32());
          continue;
        case 48:
          if (tag !== 386) {
            break;
          }

          message.nearDepth = NearDepthSearch.decode(reader, reader.uint32());
          continue;
        case 49:
          if (tag !== 394) {
            break;
          }

          message.nearThermal = NearThermalSearch.decode(reader, reader.uint32());
          continue;
        case 50:
          if (tag !== 402) {
            break;
          }

          message.nearImu = NearIMUSearch.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AggregateRequest {
    return {
      collection: isSet(object.collection) ? globalThis.String(object.collection) : "",
      tenant: isSet(object.tenant) ? globalThis.String(object.tenant) : "",
      objectsCount: isSet(object.objectsCount) ? globalThis.Boolean(object.objectsCount) : false,
      aggregations: globalThis.Array.isArray(object?.aggregations)
        ? object.aggregations.map((e: any) => AggregateRequest_Aggregation.fromJSON(e))
        : [],
      objectLimit: isSet(object.objectLimit) ? globalThis.Number(object.objectLimit) : undefined,
      groupBy: isSet(object.groupBy) ? AggregateRequest_GroupBy.fromJSON(object.groupBy) : undefined,
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : undefined,
      filters: isSet(object.filters) ? Filters.fromJSON(object.filters) : undefined,
      hybrid: isSet(object.hybrid) ? Hybrid.fromJSON(object.hybrid) : undefined,
      nearVector: isSet(object.nearVector) ? NearVector.fromJSON(object.nearVector) : undefined,
      nearObject: isSet(object.nearObject) ? NearObject.fromJSON(object.nearObject) : undefined,
      nearText: isSet(object.nearText) ? NearTextSearch.fromJSON(object.nearText) : undefined,
      nearImage: isSet(object.nearImage) ? NearImageSearch.fromJSON(object.nearImage) : undefined,
      nearAudio: isSet(object.nearAudio) ? NearAudioSearch.fromJSON(object.nearAudio) : undefined,
      nearVideo: isSet(object.nearVideo) ? NearVideoSearch.fromJSON(object.nearVideo) : undefined,
      nearDepth: isSet(object.nearDepth) ? NearDepthSearch.fromJSON(object.nearDepth) : undefined,
      nearThermal: isSet(object.nearThermal) ? NearThermalSearch.fromJSON(object.nearThermal) : undefined,
      nearImu: isSet(object.nearImu) ? NearIMUSearch.fromJSON(object.nearImu) : undefined,
    };
  },

  toJSON(message: AggregateRequest): unknown {
    const obj: any = {};
    if (message.collection !== "") {
      obj.collection = message.collection;
    }
    if (message.tenant !== "") {
      obj.tenant = message.tenant;
    }
    if (message.objectsCount !== false) {
      obj.objectsCount = message.objectsCount;
    }
    if (message.aggregations?.length) {
      obj.aggregations = message.aggregations.map((e) => AggregateRequest_Aggregation.toJSON(e));
    }
    if (message.objectLimit !== undefined) {
      obj.objectLimit = Math.round(message.objectLimit);
    }
    if (message.groupBy !== undefined) {
      obj.groupBy = AggregateRequest_GroupBy.toJSON(message.groupBy);
    }
    if (message.limit !== undefined) {
      obj.limit = Math.round(message.limit);
    }
    if (message.filters !== undefined) {
      obj.filters = Filters.toJSON(message.filters);
    }
    if (message.hybrid !== undefined) {
      obj.hybrid = Hybrid.toJSON(message.hybrid);
    }
    if (message.nearVector !== undefined) {
      obj.nearVector = NearVector.toJSON(message.nearVector);
    }
    if (message.nearObject !== undefined) {
      obj.nearObject = NearObject.toJSON(message.nearObject);
    }
    if (message.nearText !== undefined) {
      obj.nearText = NearTextSearch.toJSON(message.nearText);
    }
    if (message.nearImage !== undefined) {
      obj.nearImage = NearImageSearch.toJSON(message.nearImage);
    }
    if (message.nearAudio !== undefined) {
      obj.nearAudio = NearAudioSearch.toJSON(message.nearAudio);
    }
    if (message.nearVideo !== undefined) {
      obj.nearVideo = NearVideoSearch.toJSON(message.nearVideo);
    }
    if (message.nearDepth !== undefined) {
      obj.nearDepth = NearDepthSearch.toJSON(message.nearDepth);
    }
    if (message.nearThermal !== undefined) {
      obj.nearThermal = NearThermalSearch.toJSON(message.nearThermal);
    }
    if (message.nearImu !== undefined) {
      obj.nearImu = NearIMUSearch.toJSON(message.nearImu);
    }
    return obj;
  },

  create(base?: DeepPartial<AggregateRequest>): AggregateRequest {
    return AggregateRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AggregateRequest>): AggregateRequest {
    const message = createBaseAggregateRequest();
    message.collection = object.collection ?? "";
    message.tenant = object.tenant ?? "";
    message.objectsCount = object.objectsCount ?? false;
    message.aggregations = object.aggregations?.map((e) => AggregateRequest_Aggregation.fromPartial(e)) || [];
    message.objectLimit = object.objectLimit ?? undefined;
    message.groupBy = (object.groupBy !== undefined && object.groupBy !== null)
      ? AggregateRequest_GroupBy.fromPartial(object.groupBy)
      : undefined;
    message.limit = object.limit ?? undefined;
    message.filters = (object.filters !== undefined && object.filters !== null)
      ? Filters.fromPartial(object.filters)
      : undefined;
    message.hybrid = (object.hybrid !== undefined && object.hybrid !== null)
      ? Hybrid.fromPartial(object.hybrid)
      : undefined;
    message.nearVector = (object.nearVector !== undefined && object.nearVector !== null)
      ? NearVector.fromPartial(object.nearVector)
      : undefined;
    message.nearObject = (object.nearObject !== undefined && object.nearObject !== null)
      ? NearObject.fromPartial(object.nearObject)
      : undefined;
    message.nearText = (object.nearText !== undefined && object.nearText !== null)
      ? NearTextSearch.fromPartial(object.nearText)
      : undefined;
    message.nearImage = (object.nearImage !== undefined && object.nearImage !== null)
      ? NearImageSearch.fromPartial(object.nearImage)
      : undefined;
    message.nearAudio = (object.nearAudio !== undefined && object.nearAudio !== null)
      ? NearAudioSearch.fromPartial(object.nearAudio)
      : undefined;
    message.nearVideo = (object.nearVideo !== undefined && object.nearVideo !== null)
      ? NearVideoSearch.fromPartial(object.nearVideo)
      : undefined;
    message.nearDepth = (object.nearDepth !== undefined && object.nearDepth !== null)
      ? NearDepthSearch.fromPartial(object.nearDepth)
      : undefined;
    message.nearThermal = (object.nearThermal !== undefined && object.nearThermal !== null)
      ? NearThermalSearch.fromPartial(object.nearThermal)
      : undefined;
    message.nearImu = (object.nearImu !== undefined && object.nearImu !== null)
      ? NearIMUSearch.fromPartial(object.nearImu)
      : undefined;
    return message;
  },
};

function createBaseAggregateRequest_Aggregation(): AggregateRequest_Aggregation {
  return {
    property: "",
    int: undefined,
    number: undefined,
    text: undefined,
    boolean: undefined,
    date: undefined,
    reference: undefined,
  };
}

export const AggregateRequest_Aggregation = {
  encode(message: AggregateRequest_Aggregation, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.property !== "") {
      writer.uint32(10).string(message.property);
    }
    if (message.int !== undefined) {
      AggregateRequest_Aggregation_Integer.encode(message.int, writer.uint32(18).fork()).ldelim();
    }
    if (message.number !== undefined) {
      AggregateRequest_Aggregation_Number.encode(message.number, writer.uint32(26).fork()).ldelim();
    }
    if (message.text !== undefined) {
      AggregateRequest_Aggregation_Text.encode(message.text, writer.uint32(34).fork()).ldelim();
    }
    if (message.boolean !== undefined) {
      AggregateRequest_Aggregation_Boolean.encode(message.boolean, writer.uint32(42).fork()).ldelim();
    }
    if (message.date !== undefined) {
      AggregateRequest_Aggregation_DateMessage.encode(message.date, writer.uint32(50).fork()).ldelim();
    }
    if (message.reference !== undefined) {
      AggregateRequest_Aggregation_Reference.encode(message.reference, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AggregateRequest_Aggregation {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAggregateRequest_Aggregation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.property = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.int = AggregateRequest_Aggregation_Integer.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.number = AggregateRequest_Aggregation_Number.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.text = AggregateRequest_Aggregation_Text.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.boolean = AggregateRequest_Aggregation_Boolean.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.date = AggregateRequest_Aggregation_DateMessage.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.reference = AggregateRequest_Aggregation_Reference.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AggregateRequest_Aggregation {
    return {
      property: isSet(object.property) ? globalThis.String(object.property) : "",
      int: isSet(object.int) ? AggregateRequest_Aggregation_Integer.fromJSON(object.int) : undefined,
      number: isSet(object.number) ? AggregateRequest_Aggregation_Number.fromJSON(object.number) : undefined,
      text: isSet(object.text) ? AggregateRequest_Aggregation_Text.fromJSON(object.text) : undefined,
      boolean: isSet(object.boolean) ? AggregateRequest_Aggregation_Boolean.fromJSON(object.boolean) : undefined,
      date: isSet(object.date) ? AggregateRequest_Aggregation_DateMessage.fromJSON(object.date) : undefined,
      reference: isSet(object.reference)
        ? AggregateRequest_Aggregation_Reference.fromJSON(object.reference)
        : undefined,
    };
  },

  toJSON(message: AggregateRequest_Aggregation): unknown {
    const obj: any = {};
    if (message.property !== "") {
      obj.property = message.property;
    }
    if (message.int !== undefined) {
      obj.int = AggregateRequest_Aggregation_Integer.toJSON(message.int);
    }
    if (message.number !== undefined) {
      obj.number = AggregateRequest_Aggregation_Number.toJSON(message.number);
    }
    if (message.text !== undefined) {
      obj.text = AggregateRequest_Aggregation_Text.toJSON(message.text);
    }
    if (message.boolean !== undefined) {
      obj.boolean = AggregateRequest_Aggregation_Boolean.toJSON(message.boolean);
    }
    if (message.date !== undefined) {
      obj.date = AggregateRequest_Aggregation_DateMessage.toJSON(message.date);
    }
    if (message.reference !== undefined) {
      obj.reference = AggregateRequest_Aggregation_Reference.toJSON(message.reference);
    }
    return obj;
  },

  create(base?: DeepPartial<AggregateRequest_Aggregation>): AggregateRequest_Aggregation {
    return AggregateRequest_Aggregation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AggregateRequest_Aggregation>): AggregateRequest_Aggregation {
    const message = createBaseAggregateRequest_Aggregation();
    message.property = object.property ?? "";
    message.int = (object.int !== undefined && object.int !== null)
      ? AggregateRequest_Aggregation_Integer.fromPartial(object.int)
      : undefined;
    message.number = (object.number !== undefined && object.number !== null)
      ? AggregateRequest_Aggregation_Number.fromPartial(object.number)
      : undefined;
    message.text = (object.text !== undefined && object.text !== null)
      ? AggregateRequest_Aggregation_Text.fromPartial(object.text)
      : undefined;
    message.boolean = (object.boolean !== undefined && object.boolean !== null)
      ? AggregateRequest_Aggregation_Boolean.fromPartial(object.boolean)
      : undefined;
    message.date = (object.date !== undefined && object.date !== null)
      ? AggregateRequest_Aggregation_DateMessage.fromPartial(object.date)
      : undefined;
    message.reference = (object.reference !== undefined && object.reference !== null)
      ? AggregateRequest_Aggregation_Reference.fromPartial(object.reference)
      : undefined;
    return message;
  },
};

function createBaseAggregateRequest_Aggregation_Integer(): AggregateRequest_Aggregation_Integer {
  return {
    count: false,
    type: false,
    sum: false,
    mean: false,
    mode: false,
    median: false,
    maximum: false,
    minimum: false,
  };
}

export const AggregateRequest_Aggregation_Integer = {
  encode(message: AggregateRequest_Aggregation_Integer, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.count !== false) {
      writer.uint32(8).bool(message.count);
    }
    if (message.type !== false) {
      writer.uint32(16).bool(message.type);
    }
    if (message.sum !== false) {
      writer.uint32(24).bool(message.sum);
    }
    if (message.mean !== false) {
      writer.uint32(32).bool(message.mean);
    }
    if (message.mode !== false) {
      writer.uint32(40).bool(message.mode);
    }
    if (message.median !== false) {
      writer.uint32(48).bool(message.median);
    }
    if (message.maximum !== false) {
      writer.uint32(56).bool(message.maximum);
    }
    if (message.minimum !== false) {
      writer.uint32(64).bool(message.minimum);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AggregateRequest_Aggregation_Integer {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAggregateRequest_Aggregation_Integer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.count = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.type = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.sum = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.mean = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.mode = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.median = reader.bool();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.maximum = reader.bool();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.minimum = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AggregateRequest_Aggregation_Integer {
    return {
      count: isSet(object.count) ? globalThis.Boolean(object.count) : false,
      type: isSet(object.type) ? globalThis.Boolean(object.type) : false,
      sum: isSet(object.sum) ? globalThis.Boolean(object.sum) : false,
      mean: isSet(object.mean) ? globalThis.Boolean(object.mean) : false,
      mode: isSet(object.mode) ? globalThis.Boolean(object.mode) : false,
      median: isSet(object.median) ? globalThis.Boolean(object.median) : false,
      maximum: isSet(object.maximum) ? globalThis.Boolean(object.maximum) : false,
      minimum: isSet(object.minimum) ? globalThis.Boolean(object.minimum) : false,
    };
  },

  toJSON(message: AggregateRequest_Aggregation_Integer): unknown {
    const obj: any = {};
    if (message.count !== false) {
      obj.count = message.count;
    }
    if (message.type !== false) {
      obj.type = message.type;
    }
    if (message.sum !== false) {
      obj.sum = message.sum;
    }
    if (message.mean !== false) {
      obj.mean = message.mean;
    }
    if (message.mode !== false) {
      obj.mode = message.mode;
    }
    if (message.median !== false) {
      obj.median = message.median;
    }
    if (message.maximum !== false) {
      obj.maximum = message.maximum;
    }
    if (message.minimum !== false) {
      obj.minimum = message.minimum;
    }
    return obj;
  },

  create(base?: DeepPartial<AggregateRequest_Aggregation_Integer>): AggregateRequest_Aggregation_Integer {
    return AggregateRequest_Aggregation_Integer.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AggregateRequest_Aggregation_Integer>): AggregateRequest_Aggregation_Integer {
    const message = createBaseAggregateRequest_Aggregation_Integer();
    message.count = object.count ?? false;
    message.type = object.type ?? false;
    message.sum = object.sum ?? false;
    message.mean = object.mean ?? false;
    message.mode = object.mode ?? false;
    message.median = object.median ?? false;
    message.maximum = object.maximum ?? false;
    message.minimum = object.minimum ?? false;
    return message;
  },
};

function createBaseAggregateRequest_Aggregation_Number(): AggregateRequest_Aggregation_Number {
  return {
    count: false,
    type: false,
    sum: false,
    mean: false,
    mode: false,
    median: false,
    maximum: false,
    minimum: false,
  };
}

export const AggregateRequest_Aggregation_Number = {
  encode(message: AggregateRequest_Aggregation_Number, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.count !== false) {
      writer.uint32(8).bool(message.count);
    }
    if (message.type !== false) {
      writer.uint32(16).bool(message.type);
    }
    if (message.sum !== false) {
      writer.uint32(24).bool(message.sum);
    }
    if (message.mean !== false) {
      writer.uint32(32).bool(message.mean);
    }
    if (message.mode !== false) {
      writer.uint32(40).bool(message.mode);
    }
    if (message.median !== false) {
      writer.uint32(48).bool(message.median);
    }
    if (message.maximum !== false) {
      writer.uint32(56).bool(message.maximum);
    }
    if (message.minimum !== false) {
      writer.uint32(64).bool(message.minimum);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AggregateRequest_Aggregation_Number {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAggregateRequest_Aggregation_Number();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.count = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.type = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.sum = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.mean = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.mode = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.median = reader.bool();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.maximum = reader.bool();
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.minimum = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AggregateRequest_Aggregation_Number {
    return {
      count: isSet(object.count) ? globalThis.Boolean(object.count) : false,
      type: isSet(object.type) ? globalThis.Boolean(object.type) : false,
      sum: isSet(object.sum) ? globalThis.Boolean(object.sum) : false,
      mean: isSet(object.mean) ? globalThis.Boolean(object.mean) : false,
      mode: isSet(object.mode) ? globalThis.Boolean(object.mode) : false,
      median: isSet(object.median) ? globalThis.Boolean(object.median) : false,
      maximum: isSet(object.maximum) ? globalThis.Boolean(object.maximum) : false,
      minimum: isSet(object.minimum) ? globalThis.Boolean(object.minimum) : false,
    };
  },

  toJSON(message: AggregateRequest_Aggregation_Number): unknown {
    const obj: any = {};
    if (message.count !== false) {
      obj.count = message.count;
    }
    if (message.type !== false) {
      obj.type = message.type;
    }
    if (message.sum !== false) {
      obj.sum = message.sum;
    }
    if (message.mean !== false) {
      obj.mean = message.mean;
    }
    if (message.mode !== false) {
      obj.mode = message.mode;
    }
    if (message.median !== false) {
      obj.median = message.median;
    }
    if (message.maximum !== false) {
      obj.maximum = message.maximum;
    }
    if (message.minimum !== false) {
      obj.minimum = message.minimum;
    }
    return obj;
  },

  create(base?: DeepPartial<AggregateRequest_Aggregation_Number>): AggregateRequest_Aggregation_Number {
    return AggregateRequest_Aggregation_Number.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AggregateRequest_Aggregation_Number>): AggregateRequest_Aggregation_Number {
    const message = createBaseAggregateRequest_Aggregation_Number();
    message.count = object.count ?? false;
    message.type = object.type ?? false;
    message.sum = object.sum ?? false;
    message.mean = object.mean ?? false;
    message.mode = object.mode ?? false;
    message.median = object.median ?? false;
    message.maximum = object.maximum ?? false;
    message.minimum = object.minimum ?? false;
    return message;
  },
};

function createBaseAggregateRequest_Aggregation_Text(): AggregateRequest_Aggregation_Text {
  return { count: false, type: false, topOccurences: false, topOccurencesLimit: undefined };
}

export const AggregateRequest_Aggregation_Text = {
  encode(message: AggregateRequest_Aggregation_Text, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.count !== false) {
      writer.uint32(8).bool(message.count);
    }
    if (message.type !== false) {
      writer.uint32(16).bool(message.type);
    }
    if (message.topOccurences !== false) {
      writer.uint32(24).bool(message.topOccurences);
    }
    if (message.topOccurencesLimit !== undefined) {
      writer.uint32(32).uint32(message.topOccurencesLimit);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AggregateRequest_Aggregation_Text {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAggregateRequest_Aggregation_Text();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.count = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.type = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.topOccurences = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.topOccurencesLimit = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AggregateRequest_Aggregation_Text {
    return {
      count: isSet(object.count) ? globalThis.Boolean(object.count) : false,
      type: isSet(object.type) ? globalThis.Boolean(object.type) : false,
      topOccurences: isSet(object.topOccurences) ? globalThis.Boolean(object.topOccurences) : false,
      topOccurencesLimit: isSet(object.topOccurencesLimit) ? globalThis.Number(object.topOccurencesLimit) : undefined,
    };
  },

  toJSON(message: AggregateRequest_Aggregation_Text): unknown {
    const obj: any = {};
    if (message.count !== false) {
      obj.count = message.count;
    }
    if (message.type !== false) {
      obj.type = message.type;
    }
    if (message.topOccurences !== false) {
      obj.topOccurences = message.topOccurences;
    }
    if (message.topOccurencesLimit !== undefined) {
      obj.topOccurencesLimit = Math.round(message.topOccurencesLimit);
    }
    return obj;
  },

  create(base?: DeepPartial<AggregateRequest_Aggregation_Text>): AggregateRequest_Aggregation_Text {
    return AggregateRequest_Aggregation_Text.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AggregateRequest_Aggregation_Text>): AggregateRequest_Aggregation_Text {
    const message = createBaseAggregateRequest_Aggregation_Text();
    message.count = object.count ?? false;
    message.type = object.type ?? false;
    message.topOccurences = object.topOccurences ?? false;
    message.topOccurencesLimit = object.topOccurencesLimit ?? undefined;
    return message;
  },
};

function createBaseAggregateRequest_Aggregation_Boolean(): AggregateRequest_Aggregation_Boolean {
  return {
    count: false,
    type: false,
    totalTrue: false,
    totalFalse: false,
    percentageTrue: false,
    percentageFalse: false,
  };
}

export const AggregateRequest_Aggregation_Boolean = {
  encode(message: AggregateRequest_Aggregation_Boolean, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.count !== false) {
      writer.uint32(8).bool(message.count);
    }
    if (message.type !== false) {
      writer.uint32(16).bool(message.type);
    }
    if (message.totalTrue !== false) {
      writer.uint32(24).bool(message.totalTrue);
    }
    if (message.totalFalse !== false) {
      writer.uint32(32).bool(message.totalFalse);
    }
    if (message.percentageTrue !== false) {
      writer.uint32(40).bool(message.percentageTrue);
    }
    if (message.percentageFalse !== false) {
      writer.uint32(48).bool(message.percentageFalse);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AggregateRequest_Aggregation_Boolean {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAggregateRequest_Aggregation_Boolean();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.count = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.type = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.totalTrue = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.totalFalse = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.percentageTrue = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.percentageFalse = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AggregateRequest_Aggregation_Boolean {
    return {
      count: isSet(object.count) ? globalThis.Boolean(object.count) : false,
      type: isSet(object.type) ? globalThis.Boolean(object.type) : false,
      totalTrue: isSet(object.totalTrue) ? globalThis.Boolean(object.totalTrue) : false,
      totalFalse: isSet(object.totalFalse) ? globalThis.Boolean(object.totalFalse) : false,
      percentageTrue: isSet(object.percentageTrue) ? globalThis.Boolean(object.percentageTrue) : false,
      percentageFalse: isSet(object.percentageFalse) ? globalThis.Boolean(object.percentageFalse) : false,
    };
  },

  toJSON(message: AggregateRequest_Aggregation_Boolean): unknown {
    const obj: any = {};
    if (message.count !== false) {
      obj.count = message.count;
    }
    if (message.type !== false) {
      obj.type = message.type;
    }
    if (message.totalTrue !== false) {
      obj.totalTrue = message.totalTrue;
    }
    if (message.totalFalse !== false) {
      obj.totalFalse = message.totalFalse;
    }
    if (message.percentageTrue !== false) {
      obj.percentageTrue = message.percentageTrue;
    }
    if (message.percentageFalse !== false) {
      obj.percentageFalse = message.percentageFalse;
    }
    return obj;
  },

  create(base?: DeepPartial<AggregateRequest_Aggregation_Boolean>): AggregateRequest_Aggregation_Boolean {
    return AggregateRequest_Aggregation_Boolean.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AggregateRequest_Aggregation_Boolean>): AggregateRequest_Aggregation_Boolean {
    const message = createBaseAggregateRequest_Aggregation_Boolean();
    message.count = object.count ?? false;
    message.type = object.type ?? false;
    message.totalTrue = object.totalTrue ?? false;
    message.totalFalse = object.totalFalse ?? false;
    message.percentageTrue = object.percentageTrue ?? false;
    message.percentageFalse = object.percentageFalse ?? false;
    return message;
  },
};

function createBaseAggregateRequest_Aggregation_DateMessage(): AggregateRequest_Aggregation_DateMessage {
  return { count: false, type: false, median: false, mode: false, maximum: false, minimum: false };
}

export const AggregateRequest_Aggregation_DateMessage = {
  encode(message: AggregateRequest_Aggregation_DateMessage, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.count !== false) {
      writer.uint32(8).bool(message.count);
    }
    if (message.type !== false) {
      writer.uint32(16).bool(message.type);
    }
    if (message.median !== false) {
      writer.uint32(24).bool(message.median);
    }
    if (message.mode !== false) {
      writer.uint32(32).bool(message.mode);
    }
    if (message.maximum !== false) {
      writer.uint32(40).bool(message.maximum);
    }
    if (message.minimum !== false) {
      writer.uint32(48).bool(message.minimum);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AggregateRequest_Aggregation_DateMessage {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAggregateRequest_Aggregation_DateMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.count = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.type = reader.bool();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.median = reader.bool();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.mode = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.maximum = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.minimum = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AggregateRequest_Aggregation_DateMessage {
    return {
      count: isSet(object.count) ? globalThis.Boolean(object.count) : false,
      type: isSet(object.type) ? globalThis.Boolean(object.type) : false,
      median: isSet(object.median) ? globalThis.Boolean(object.median) : false,
      mode: isSet(object.mode) ? globalThis.Boolean(object.mode) : false,
      maximum: isSet(object.maximum) ? globalThis.Boolean(object.maximum) : false,
      minimum: isSet(object.minimum) ? globalThis.Boolean(object.minimum) : false,
    };
  },

  toJSON(message: AggregateRequest_Aggregation_DateMessage): unknown {
    const obj: any = {};
    if (message.count !== false) {
      obj.count = message.count;
    }
    if (message.type !== false) {
      obj.type = message.type;
    }
    if (message.median !== false) {
      obj.median = message.median;
    }
    if (message.mode !== false) {
      obj.mode = message.mode;
    }
    if (message.maximum !== false) {
      obj.maximum = message.maximum;
    }
    if (message.minimum !== false) {
      obj.minimum = message.minimum;
    }
    return obj;
  },

  create(base?: DeepPartial<AggregateRequest_Aggregation_DateMessage>): AggregateRequest_Aggregation_DateMessage {
    return AggregateRequest_Aggregation_DateMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AggregateRequest_Aggregation_DateMessage>): AggregateRequest_Aggregation_DateMessage {
    const message = createBaseAggregateRequest_Aggregation_DateMessage();
    message.count = object.count ?? false;
    message.type = object.type ?? false;
    message.median = object.median ?? false;
    message.mode = object.mode ?? false;
    message.maximum = object.maximum ?? false;
    message.minimum = object.minimum ?? false;
    return message;
  },
};

function createBaseAggregateRequest_Aggregation_Reference(): AggregateRequest_Aggregation_Reference {
  return { type: false, pointingTo: false };
}

export const AggregateRequest_Aggregation_Reference = {
  encode(message: AggregateRequest_Aggregation_Reference, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.type !== false) {
      writer.uint32(8).bool(message.type);
    }
    if (message.pointingTo !== false) {
      writer.uint32(16).bool(message.pointingTo);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AggregateRequest_Aggregation_Reference {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAggregateRequest_Aggregation_Reference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.bool();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.pointingTo = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AggregateRequest_Aggregation_Reference {
    return {
      type: isSet(object.type) ? globalThis.Boolean(object.type) : false,
      pointingTo: isSet(object.pointingTo) ? globalThis.Boolean(object.pointingTo) : false,
    };
  },

  toJSON(message: AggregateRequest_Aggregation_Reference): unknown {
    const obj: any = {};
    if (message.type !== false) {
      obj.type = message.type;
    }
    if (message.pointingTo !== false) {
      obj.pointingTo = message.pointingTo;
    }
    return obj;
  },

  create(base?: DeepPartial<AggregateRequest_Aggregation_Reference>): AggregateRequest_Aggregation_Reference {
    return AggregateRequest_Aggregation_Reference.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AggregateRequest_Aggregation_Reference>): AggregateRequest_Aggregation_Reference {
    const message = createBaseAggregateRequest_Aggregation_Reference();
    message.type = object.type ?? false;
    message.pointingTo = object.pointingTo ?? false;
    return message;
  },
};

function createBaseAggregateRequest_GroupBy(): AggregateRequest_GroupBy {
  return { collection: "", property: "" };
}

export const AggregateRequest_GroupBy = {
  encode(message: AggregateRequest_GroupBy, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.collection !== "") {
      writer.uint32(10).string(message.collection);
    }
    if (message.property !== "") {
      writer.uint32(18).string(message.property);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AggregateRequest_GroupBy {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAggregateRequest_GroupBy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.collection = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.property = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AggregateRequest_GroupBy {
    return {
      collection: isSet(object.collection) ? globalThis.String(object.collection) : "",
      property: isSet(object.property) ? globalThis.String(object.property) : "",
    };
  },

  toJSON(message: AggregateRequest_GroupBy): unknown {
    const obj: any = {};
    if (message.collection !== "") {
      obj.collection = message.collection;
    }
    if (message.property !== "") {
      obj.property = message.property;
    }
    return obj;
  },

  create(base?: DeepPartial<AggregateRequest_GroupBy>): AggregateRequest_GroupBy {
    return AggregateRequest_GroupBy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AggregateRequest_GroupBy>): AggregateRequest_GroupBy {
    const message = createBaseAggregateRequest_GroupBy();
    message.collection = object.collection ?? "";
    message.property = object.property ?? "";
    return message;
  },
};

function createBaseAggregateReply(): AggregateReply {
  return { took: 0, singleResult: undefined, groupedResults: undefined };
}

export const AggregateReply = {
  encode(message: AggregateReply, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.took !== 0) {
      writer.uint32(13).float(message.took);
    }
    if (message.singleResult !== undefined) {
      AggregateReply_Single.encode(message.singleResult, writer.uint32(18).fork()).ldelim();
    }
    if (message.groupedResults !== undefined) {
      AggregateReply_Grouped.encode(message.groupedResults, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AggregateReply {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAggregateReply();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.took = reader.float();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.singleResult = AggregateReply_Single.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.groupedResults = AggregateReply_Grouped.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AggregateReply {
    return {
      took: isSet(object.took) ? globalThis.Number(object.took) : 0,
      singleResult: isSet(object.singleResult) ? AggregateReply_Single.fromJSON(object.singleResult) : undefined,
      groupedResults: isSet(object.groupedResults) ? AggregateReply_Grouped.fromJSON(object.groupedResults) : undefined,
    };
  },

  toJSON(message: AggregateReply): unknown {
    const obj: any = {};
    if (message.took !== 0) {
      obj.took = message.took;
    }
    if (message.singleResult !== undefined) {
      obj.singleResult = AggregateReply_Single.toJSON(message.singleResult);
    }
    if (message.groupedResults !== undefined) {
      obj.groupedResults = AggregateReply_Grouped.toJSON(message.groupedResults);
    }
    return obj;
  },

  create(base?: DeepPartial<AggregateReply>): AggregateReply {
    return AggregateReply.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AggregateReply>): AggregateReply {
    const message = createBaseAggregateReply();
    message.took = object.took ?? 0;
    message.singleResult = (object.singleResult !== undefined && object.singleResult !== null)
      ? AggregateReply_Single.fromPartial(object.singleResult)
      : undefined;
    message.groupedResults = (object.groupedResults !== undefined && object.groupedResults !== null)
      ? AggregateReply_Grouped.fromPartial(object.groupedResults)
      : undefined;
    return message;
  },
};

function createBaseAggregateReply_Aggregations(): AggregateReply_Aggregations {
  return { aggregations: [] };
}

export const AggregateReply_Aggregations = {
  encode(message: AggregateReply_Aggregations, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.aggregations) {
      AggregateReply_Aggregations_Aggregation.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AggregateReply_Aggregations {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAggregateReply_Aggregations();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.aggregations.push(AggregateReply_Aggregations_Aggregation.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AggregateReply_Aggregations {
    return {
      aggregations: globalThis.Array.isArray(object?.aggregations)
        ? object.aggregations.map((e: any) => AggregateReply_Aggregations_Aggregation.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AggregateReply_Aggregations): unknown {
    const obj: any = {};
    if (message.aggregations?.length) {
      obj.aggregations = message.aggregations.map((e) => AggregateReply_Aggregations_Aggregation.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<AggregateReply_Aggregations>): AggregateReply_Aggregations {
    return AggregateReply_Aggregations.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AggregateReply_Aggregations>): AggregateReply_Aggregations {
    const message = createBaseAggregateReply_Aggregations();
    message.aggregations = object.aggregations?.map((e) => AggregateReply_Aggregations_Aggregation.fromPartial(e)) ||
      [];
    return message;
  },
};

function createBaseAggregateReply_Aggregations_Aggregation(): AggregateReply_Aggregations_Aggregation {
  return {
    property: "",
    int: undefined,
    number: undefined,
    text: undefined,
    boolean: undefined,
    date: undefined,
    reference: undefined,
  };
}

export const AggregateReply_Aggregations_Aggregation = {
  encode(message: AggregateReply_Aggregations_Aggregation, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.property !== "") {
      writer.uint32(10).string(message.property);
    }
    if (message.int !== undefined) {
      AggregateReply_Aggregations_Aggregation_Integer.encode(message.int, writer.uint32(18).fork()).ldelim();
    }
    if (message.number !== undefined) {
      AggregateReply_Aggregations_Aggregation_Number.encode(message.number, writer.uint32(26).fork()).ldelim();
    }
    if (message.text !== undefined) {
      AggregateReply_Aggregations_Aggregation_Text.encode(message.text, writer.uint32(34).fork()).ldelim();
    }
    if (message.boolean !== undefined) {
      AggregateReply_Aggregations_Aggregation_Boolean.encode(message.boolean, writer.uint32(42).fork()).ldelim();
    }
    if (message.date !== undefined) {
      AggregateReply_Aggregations_Aggregation_DateMessage.encode(message.date, writer.uint32(50).fork()).ldelim();
    }
    if (message.reference !== undefined) {
      AggregateReply_Aggregations_Aggregation_Reference.encode(message.reference, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AggregateReply_Aggregations_Aggregation {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAggregateReply_Aggregations_Aggregation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.property = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.int = AggregateReply_Aggregations_Aggregation_Integer.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.number = AggregateReply_Aggregations_Aggregation_Number.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.text = AggregateReply_Aggregations_Aggregation_Text.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.boolean = AggregateReply_Aggregations_Aggregation_Boolean.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.date = AggregateReply_Aggregations_Aggregation_DateMessage.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.reference = AggregateReply_Aggregations_Aggregation_Reference.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AggregateReply_Aggregations_Aggregation {
    return {
      property: isSet(object.property) ? globalThis.String(object.property) : "",
      int: isSet(object.int) ? AggregateReply_Aggregations_Aggregation_Integer.fromJSON(object.int) : undefined,
      number: isSet(object.number) ? AggregateReply_Aggregations_Aggregation_Number.fromJSON(object.number) : undefined,
      text: isSet(object.text) ? AggregateReply_Aggregations_Aggregation_Text.fromJSON(object.text) : undefined,
      boolean: isSet(object.boolean)
        ? AggregateReply_Aggregations_Aggregation_Boolean.fromJSON(object.boolean)
        : undefined,
      date: isSet(object.date) ? AggregateReply_Aggregations_Aggregation_DateMessage.fromJSON(object.date) : undefined,
      reference: isSet(object.reference)
        ? AggregateReply_Aggregations_Aggregation_Reference.fromJSON(object.reference)
        : undefined,
    };
  },

  toJSON(message: AggregateReply_Aggregations_Aggregation): unknown {
    const obj: any = {};
    if (message.property !== "") {
      obj.property = message.property;
    }
    if (message.int !== undefined) {
      obj.int = AggregateReply_Aggregations_Aggregation_Integer.toJSON(message.int);
    }
    if (message.number !== undefined) {
      obj.number = AggregateReply_Aggregations_Aggregation_Number.toJSON(message.number);
    }
    if (message.text !== undefined) {
      obj.text = AggregateReply_Aggregations_Aggregation_Text.toJSON(message.text);
    }
    if (message.boolean !== undefined) {
      obj.boolean = AggregateReply_Aggregations_Aggregation_Boolean.toJSON(message.boolean);
    }
    if (message.date !== undefined) {
      obj.date = AggregateReply_Aggregations_Aggregation_DateMessage.toJSON(message.date);
    }
    if (message.reference !== undefined) {
      obj.reference = AggregateReply_Aggregations_Aggregation_Reference.toJSON(message.reference);
    }
    return obj;
  },

  create(base?: DeepPartial<AggregateReply_Aggregations_Aggregation>): AggregateReply_Aggregations_Aggregation {
    return AggregateReply_Aggregations_Aggregation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AggregateReply_Aggregations_Aggregation>): AggregateReply_Aggregations_Aggregation {
    const message = createBaseAggregateReply_Aggregations_Aggregation();
    message.property = object.property ?? "";
    message.int = (object.int !== undefined && object.int !== null)
      ? AggregateReply_Aggregations_Aggregation_Integer.fromPartial(object.int)
      : undefined;
    message.number = (object.number !== undefined && object.number !== null)
      ? AggregateReply_Aggregations_Aggregation_Number.fromPartial(object.number)
      : undefined;
    message.text = (object.text !== undefined && object.text !== null)
      ? AggregateReply_Aggregations_Aggregation_Text.fromPartial(object.text)
      : undefined;
    message.boolean = (object.boolean !== undefined && object.boolean !== null)
      ? AggregateReply_Aggregations_Aggregation_Boolean.fromPartial(object.boolean)
      : undefined;
    message.date = (object.date !== undefined && object.date !== null)
      ? AggregateReply_Aggregations_Aggregation_DateMessage.fromPartial(object.date)
      : undefined;
    message.reference = (object.reference !== undefined && object.reference !== null)
      ? AggregateReply_Aggregations_Aggregation_Reference.fromPartial(object.reference)
      : undefined;
    return message;
  },
};

function createBaseAggregateReply_Aggregations_Aggregation_Integer(): AggregateReply_Aggregations_Aggregation_Integer {
  return {
    count: undefined,
    type: undefined,
    mean: undefined,
    median: undefined,
    mode: undefined,
    maximum: undefined,
    minimum: undefined,
    sum: undefined,
  };
}

export const AggregateReply_Aggregations_Aggregation_Integer = {
  encode(
    message: AggregateReply_Aggregations_Aggregation_Integer,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.count !== undefined) {
      writer.uint32(8).int64(message.count);
    }
    if (message.type !== undefined) {
      writer.uint32(18).string(message.type);
    }
    if (message.mean !== undefined) {
      writer.uint32(25).double(message.mean);
    }
    if (message.median !== undefined) {
      writer.uint32(33).double(message.median);
    }
    if (message.mode !== undefined) {
      writer.uint32(40).int64(message.mode);
    }
    if (message.maximum !== undefined) {
      writer.uint32(48).int64(message.maximum);
    }
    if (message.minimum !== undefined) {
      writer.uint32(56).int64(message.minimum);
    }
    if (message.sum !== undefined) {
      writer.uint32(64).int64(message.sum);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AggregateReply_Aggregations_Aggregation_Integer {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAggregateReply_Aggregations_Aggregation_Integer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.count = longToNumber(reader.int64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.type = reader.string();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.mean = reader.double();
          continue;
        case 4:
          if (tag !== 33) {
            break;
          }

          message.median = reader.double();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.mode = longToNumber(reader.int64() as Long);
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.maximum = longToNumber(reader.int64() as Long);
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.minimum = longToNumber(reader.int64() as Long);
          continue;
        case 8:
          if (tag !== 64) {
            break;
          }

          message.sum = longToNumber(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AggregateReply_Aggregations_Aggregation_Integer {
    return {
      count: isSet(object.count) ? globalThis.Number(object.count) : undefined,
      type: isSet(object.type) ? globalThis.String(object.type) : undefined,
      mean: isSet(object.mean) ? globalThis.Number(object.mean) : undefined,
      median: isSet(object.median) ? globalThis.Number(object.median) : undefined,
      mode: isSet(object.mode) ? globalThis.Number(object.mode) : undefined,
      maximum: isSet(object.maximum) ? globalThis.Number(object.maximum) : undefined,
      minimum: isSet(object.minimum) ? globalThis.Number(object.minimum) : undefined,
      sum: isSet(object.sum) ? globalThis.Number(object.sum) : undefined,
    };
  },

  toJSON(message: AggregateReply_Aggregations_Aggregation_Integer): unknown {
    const obj: any = {};
    if (message.count !== undefined) {
      obj.count = Math.round(message.count);
    }
    if (message.type !== undefined) {
      obj.type = message.type;
    }
    if (message.mean !== undefined) {
      obj.mean = message.mean;
    }
    if (message.median !== undefined) {
      obj.median = message.median;
    }
    if (message.mode !== undefined) {
      obj.mode = Math.round(message.mode);
    }
    if (message.maximum !== undefined) {
      obj.maximum = Math.round(message.maximum);
    }
    if (message.minimum !== undefined) {
      obj.minimum = Math.round(message.minimum);
    }
    if (message.sum !== undefined) {
      obj.sum = Math.round(message.sum);
    }
    return obj;
  },

  create(
    base?: DeepPartial<AggregateReply_Aggregations_Aggregation_Integer>,
  ): AggregateReply_Aggregations_Aggregation_Integer {
    return AggregateReply_Aggregations_Aggregation_Integer.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<AggregateReply_Aggregations_Aggregation_Integer>,
  ): AggregateReply_Aggregations_Aggregation_Integer {
    const message = createBaseAggregateReply_Aggregations_Aggregation_Integer();
    message.count = object.count ?? undefined;
    message.type = object.type ?? undefined;
    message.mean = object.mean ?? undefined;
    message.median = object.median ?? undefined;
    message.mode = object.mode ?? undefined;
    message.maximum = object.maximum ?? undefined;
    message.minimum = object.minimum ?? undefined;
    message.sum = object.sum ?? undefined;
    return message;
  },
};

function createBaseAggregateReply_Aggregations_Aggregation_Number(): AggregateReply_Aggregations_Aggregation_Number {
  return {
    count: undefined,
    type: undefined,
    mean: undefined,
    median: undefined,
    mode: undefined,
    maximum: undefined,
    minimum: undefined,
    sum: undefined,
  };
}

export const AggregateReply_Aggregations_Aggregation_Number = {
  encode(
    message: AggregateReply_Aggregations_Aggregation_Number,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.count !== undefined) {
      writer.uint32(8).int64(message.count);
    }
    if (message.type !== undefined) {
      writer.uint32(18).string(message.type);
    }
    if (message.mean !== undefined) {
      writer.uint32(25).double(message.mean);
    }
    if (message.median !== undefined) {
      writer.uint32(33).double(message.median);
    }
    if (message.mode !== undefined) {
      writer.uint32(41).double(message.mode);
    }
    if (message.maximum !== undefined) {
      writer.uint32(49).double(message.maximum);
    }
    if (message.minimum !== undefined) {
      writer.uint32(57).double(message.minimum);
    }
    if (message.sum !== undefined) {
      writer.uint32(65).double(message.sum);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AggregateReply_Aggregations_Aggregation_Number {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAggregateReply_Aggregations_Aggregation_Number();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.count = longToNumber(reader.int64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.type = reader.string();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.mean = reader.double();
          continue;
        case 4:
          if (tag !== 33) {
            break;
          }

          message.median = reader.double();
          continue;
        case 5:
          if (tag !== 41) {
            break;
          }

          message.mode = reader.double();
          continue;
        case 6:
          if (tag !== 49) {
            break;
          }

          message.maximum = reader.double();
          continue;
        case 7:
          if (tag !== 57) {
            break;
          }

          message.minimum = reader.double();
          continue;
        case 8:
          if (tag !== 65) {
            break;
          }

          message.sum = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AggregateReply_Aggregations_Aggregation_Number {
    return {
      count: isSet(object.count) ? globalThis.Number(object.count) : undefined,
      type: isSet(object.type) ? globalThis.String(object.type) : undefined,
      mean: isSet(object.mean) ? globalThis.Number(object.mean) : undefined,
      median: isSet(object.median) ? globalThis.Number(object.median) : undefined,
      mode: isSet(object.mode) ? globalThis.Number(object.mode) : undefined,
      maximum: isSet(object.maximum) ? globalThis.Number(object.maximum) : undefined,
      minimum: isSet(object.minimum) ? globalThis.Number(object.minimum) : undefined,
      sum: isSet(object.sum) ? globalThis.Number(object.sum) : undefined,
    };
  },

  toJSON(message: AggregateReply_Aggregations_Aggregation_Number): unknown {
    const obj: any = {};
    if (message.count !== undefined) {
      obj.count = Math.round(message.count);
    }
    if (message.type !== undefined) {
      obj.type = message.type;
    }
    if (message.mean !== undefined) {
      obj.mean = message.mean;
    }
    if (message.median !== undefined) {
      obj.median = message.median;
    }
    if (message.mode !== undefined) {
      obj.mode = message.mode;
    }
    if (message.maximum !== undefined) {
      obj.maximum = message.maximum;
    }
    if (message.minimum !== undefined) {
      obj.minimum = message.minimum;
    }
    if (message.sum !== undefined) {
      obj.sum = message.sum;
    }
    return obj;
  },

  create(
    base?: DeepPartial<AggregateReply_Aggregations_Aggregation_Number>,
  ): AggregateReply_Aggregations_Aggregation_Number {
    return AggregateReply_Aggregations_Aggregation_Number.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<AggregateReply_Aggregations_Aggregation_Number>,
  ): AggregateReply_Aggregations_Aggregation_Number {
    const message = createBaseAggregateReply_Aggregations_Aggregation_Number();
    message.count = object.count ?? undefined;
    message.type = object.type ?? undefined;
    message.mean = object.mean ?? undefined;
    message.median = object.median ?? undefined;
    message.mode = object.mode ?? undefined;
    message.maximum = object.maximum ?? undefined;
    message.minimum = object.minimum ?? undefined;
    message.sum = object.sum ?? undefined;
    return message;
  },
};

function createBaseAggregateReply_Aggregations_Aggregation_Text(): AggregateReply_Aggregations_Aggregation_Text {
  return { count: undefined, type: undefined, topOccurences: undefined };
}

export const AggregateReply_Aggregations_Aggregation_Text = {
  encode(message: AggregateReply_Aggregations_Aggregation_Text, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.count !== undefined) {
      writer.uint32(8).int64(message.count);
    }
    if (message.type !== undefined) {
      writer.uint32(18).string(message.type);
    }
    if (message.topOccurences !== undefined) {
      AggregateReply_Aggregations_Aggregation_Text_TopOccurrences.encode(
        message.topOccurences,
        writer.uint32(26).fork(),
      ).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AggregateReply_Aggregations_Aggregation_Text {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAggregateReply_Aggregations_Aggregation_Text();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.count = longToNumber(reader.int64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.type = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.topOccurences = AggregateReply_Aggregations_Aggregation_Text_TopOccurrences.decode(
            reader,
            reader.uint32(),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AggregateReply_Aggregations_Aggregation_Text {
    return {
      count: isSet(object.count) ? globalThis.Number(object.count) : undefined,
      type: isSet(object.type) ? globalThis.String(object.type) : undefined,
      topOccurences: isSet(object.topOccurences)
        ? AggregateReply_Aggregations_Aggregation_Text_TopOccurrences.fromJSON(object.topOccurences)
        : undefined,
    };
  },

  toJSON(message: AggregateReply_Aggregations_Aggregation_Text): unknown {
    const obj: any = {};
    if (message.count !== undefined) {
      obj.count = Math.round(message.count);
    }
    if (message.type !== undefined) {
      obj.type = message.type;
    }
    if (message.topOccurences !== undefined) {
      obj.topOccurences = AggregateReply_Aggregations_Aggregation_Text_TopOccurrences.toJSON(message.topOccurences);
    }
    return obj;
  },

  create(
    base?: DeepPartial<AggregateReply_Aggregations_Aggregation_Text>,
  ): AggregateReply_Aggregations_Aggregation_Text {
    return AggregateReply_Aggregations_Aggregation_Text.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<AggregateReply_Aggregations_Aggregation_Text>,
  ): AggregateReply_Aggregations_Aggregation_Text {
    const message = createBaseAggregateReply_Aggregations_Aggregation_Text();
    message.count = object.count ?? undefined;
    message.type = object.type ?? undefined;
    message.topOccurences = (object.topOccurences !== undefined && object.topOccurences !== null)
      ? AggregateReply_Aggregations_Aggregation_Text_TopOccurrences.fromPartial(object.topOccurences)
      : undefined;
    return message;
  },
};

function createBaseAggregateReply_Aggregations_Aggregation_Text_TopOccurrences(): AggregateReply_Aggregations_Aggregation_Text_TopOccurrences {
  return { items: [] };
}

export const AggregateReply_Aggregations_Aggregation_Text_TopOccurrences = {
  encode(
    message: AggregateReply_Aggregations_Aggregation_Text_TopOccurrences,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    for (const v of message.items) {
      AggregateReply_Aggregations_Aggregation_Text_TopOccurrences_TopOccurrence.encode(v!, writer.uint32(10).fork())
        .ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AggregateReply_Aggregations_Aggregation_Text_TopOccurrences {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAggregateReply_Aggregations_Aggregation_Text_TopOccurrences();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.items.push(
            AggregateReply_Aggregations_Aggregation_Text_TopOccurrences_TopOccurrence.decode(reader, reader.uint32()),
          );
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AggregateReply_Aggregations_Aggregation_Text_TopOccurrences {
    return {
      items: globalThis.Array.isArray(object?.items)
        ? object.items.map((e: any) =>
          AggregateReply_Aggregations_Aggregation_Text_TopOccurrences_TopOccurrence.fromJSON(e)
        )
        : [],
    };
  },

  toJSON(message: AggregateReply_Aggregations_Aggregation_Text_TopOccurrences): unknown {
    const obj: any = {};
    if (message.items?.length) {
      obj.items = message.items.map((e) =>
        AggregateReply_Aggregations_Aggregation_Text_TopOccurrences_TopOccurrence.toJSON(e)
      );
    }
    return obj;
  },

  create(
    base?: DeepPartial<AggregateReply_Aggregations_Aggregation_Text_TopOccurrences>,
  ): AggregateReply_Aggregations_Aggregation_Text_TopOccurrences {
    return AggregateReply_Aggregations_Aggregation_Text_TopOccurrences.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<AggregateReply_Aggregations_Aggregation_Text_TopOccurrences>,
  ): AggregateReply_Aggregations_Aggregation_Text_TopOccurrences {
    const message = createBaseAggregateReply_Aggregations_Aggregation_Text_TopOccurrences();
    message.items =
      object.items?.map((e) =>
        AggregateReply_Aggregations_Aggregation_Text_TopOccurrences_TopOccurrence.fromPartial(e)
      ) || [];
    return message;
  },
};

function createBaseAggregateReply_Aggregations_Aggregation_Text_TopOccurrences_TopOccurrence(): AggregateReply_Aggregations_Aggregation_Text_TopOccurrences_TopOccurrence {
  return { value: "", occurs: 0 };
}

export const AggregateReply_Aggregations_Aggregation_Text_TopOccurrences_TopOccurrence = {
  encode(
    message: AggregateReply_Aggregations_Aggregation_Text_TopOccurrences_TopOccurrence,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.value !== "") {
      writer.uint32(10).string(message.value);
    }
    if (message.occurs !== 0) {
      writer.uint32(16).int64(message.occurs);
    }
    return writer;
  },

  decode(
    input: _m0.Reader | Uint8Array,
    length?: number,
  ): AggregateReply_Aggregations_Aggregation_Text_TopOccurrences_TopOccurrence {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAggregateReply_Aggregations_Aggregation_Text_TopOccurrences_TopOccurrence();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.value = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.occurs = longToNumber(reader.int64() as Long);
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AggregateReply_Aggregations_Aggregation_Text_TopOccurrences_TopOccurrence {
    return {
      value: isSet(object.value) ? globalThis.String(object.value) : "",
      occurs: isSet(object.occurs) ? globalThis.Number(object.occurs) : 0,
    };
  },

  toJSON(message: AggregateReply_Aggregations_Aggregation_Text_TopOccurrences_TopOccurrence): unknown {
    const obj: any = {};
    if (message.value !== "") {
      obj.value = message.value;
    }
    if (message.occurs !== 0) {
      obj.occurs = Math.round(message.occurs);
    }
    return obj;
  },

  create(
    base?: DeepPartial<AggregateReply_Aggregations_Aggregation_Text_TopOccurrences_TopOccurrence>,
  ): AggregateReply_Aggregations_Aggregation_Text_TopOccurrences_TopOccurrence {
    return AggregateReply_Aggregations_Aggregation_Text_TopOccurrences_TopOccurrence.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<AggregateReply_Aggregations_Aggregation_Text_TopOccurrences_TopOccurrence>,
  ): AggregateReply_Aggregations_Aggregation_Text_TopOccurrences_TopOccurrence {
    const message = createBaseAggregateReply_Aggregations_Aggregation_Text_TopOccurrences_TopOccurrence();
    message.value = object.value ?? "";
    message.occurs = object.occurs ?? 0;
    return message;
  },
};

function createBaseAggregateReply_Aggregations_Aggregation_Boolean(): AggregateReply_Aggregations_Aggregation_Boolean {
  return {
    count: undefined,
    type: undefined,
    totalTrue: undefined,
    totalFalse: undefined,
    percentageTrue: undefined,
    percentageFalse: undefined,
  };
}

export const AggregateReply_Aggregations_Aggregation_Boolean = {
  encode(
    message: AggregateReply_Aggregations_Aggregation_Boolean,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.count !== undefined) {
      writer.uint32(8).int64(message.count);
    }
    if (message.type !== undefined) {
      writer.uint32(18).string(message.type);
    }
    if (message.totalTrue !== undefined) {
      writer.uint32(24).int64(message.totalTrue);
    }
    if (message.totalFalse !== undefined) {
      writer.uint32(32).int64(message.totalFalse);
    }
    if (message.percentageTrue !== undefined) {
      writer.uint32(41).double(message.percentageTrue);
    }
    if (message.percentageFalse !== undefined) {
      writer.uint32(49).double(message.percentageFalse);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AggregateReply_Aggregations_Aggregation_Boolean {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAggregateReply_Aggregations_Aggregation_Boolean();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.count = longToNumber(reader.int64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.type = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.totalTrue = longToNumber(reader.int64() as Long);
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.totalFalse = longToNumber(reader.int64() as Long);
          continue;
        case 5:
          if (tag !== 41) {
            break;
          }

          message.percentageTrue = reader.double();
          continue;
        case 6:
          if (tag !== 49) {
            break;
          }

          message.percentageFalse = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AggregateReply_Aggregations_Aggregation_Boolean {
    return {
      count: isSet(object.count) ? globalThis.Number(object.count) : undefined,
      type: isSet(object.type) ? globalThis.String(object.type) : undefined,
      totalTrue: isSet(object.totalTrue) ? globalThis.Number(object.totalTrue) : undefined,
      totalFalse: isSet(object.totalFalse) ? globalThis.Number(object.totalFalse) : undefined,
      percentageTrue: isSet(object.percentageTrue) ? globalThis.Number(object.percentageTrue) : undefined,
      percentageFalse: isSet(object.percentageFalse) ? globalThis.Number(object.percentageFalse) : undefined,
    };
  },

  toJSON(message: AggregateReply_Aggregations_Aggregation_Boolean): unknown {
    const obj: any = {};
    if (message.count !== undefined) {
      obj.count = Math.round(message.count);
    }
    if (message.type !== undefined) {
      obj.type = message.type;
    }
    if (message.totalTrue !== undefined) {
      obj.totalTrue = Math.round(message.totalTrue);
    }
    if (message.totalFalse !== undefined) {
      obj.totalFalse = Math.round(message.totalFalse);
    }
    if (message.percentageTrue !== undefined) {
      obj.percentageTrue = message.percentageTrue;
    }
    if (message.percentageFalse !== undefined) {
      obj.percentageFalse = message.percentageFalse;
    }
    return obj;
  },

  create(
    base?: DeepPartial<AggregateReply_Aggregations_Aggregation_Boolean>,
  ): AggregateReply_Aggregations_Aggregation_Boolean {
    return AggregateReply_Aggregations_Aggregation_Boolean.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<AggregateReply_Aggregations_Aggregation_Boolean>,
  ): AggregateReply_Aggregations_Aggregation_Boolean {
    const message = createBaseAggregateReply_Aggregations_Aggregation_Boolean();
    message.count = object.count ?? undefined;
    message.type = object.type ?? undefined;
    message.totalTrue = object.totalTrue ?? undefined;
    message.totalFalse = object.totalFalse ?? undefined;
    message.percentageTrue = object.percentageTrue ?? undefined;
    message.percentageFalse = object.percentageFalse ?? undefined;
    return message;
  },
};

function createBaseAggregateReply_Aggregations_Aggregation_DateMessage(): AggregateReply_Aggregations_Aggregation_DateMessage {
  return {
    count: undefined,
    type: undefined,
    median: undefined,
    mode: undefined,
    maximum: undefined,
    minimum: undefined,
  };
}

export const AggregateReply_Aggregations_Aggregation_DateMessage = {
  encode(
    message: AggregateReply_Aggregations_Aggregation_DateMessage,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.count !== undefined) {
      writer.uint32(8).int64(message.count);
    }
    if (message.type !== undefined) {
      writer.uint32(18).string(message.type);
    }
    if (message.median !== undefined) {
      writer.uint32(26).string(message.median);
    }
    if (message.mode !== undefined) {
      writer.uint32(34).string(message.mode);
    }
    if (message.maximum !== undefined) {
      writer.uint32(42).string(message.maximum);
    }
    if (message.minimum !== undefined) {
      writer.uint32(50).string(message.minimum);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AggregateReply_Aggregations_Aggregation_DateMessage {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAggregateReply_Aggregations_Aggregation_DateMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.count = longToNumber(reader.int64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.type = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.median = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.mode = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.maximum = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.minimum = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AggregateReply_Aggregations_Aggregation_DateMessage {
    return {
      count: isSet(object.count) ? globalThis.Number(object.count) : undefined,
      type: isSet(object.type) ? globalThis.String(object.type) : undefined,
      median: isSet(object.median) ? globalThis.String(object.median) : undefined,
      mode: isSet(object.mode) ? globalThis.String(object.mode) : undefined,
      maximum: isSet(object.maximum) ? globalThis.String(object.maximum) : undefined,
      minimum: isSet(object.minimum) ? globalThis.String(object.minimum) : undefined,
    };
  },

  toJSON(message: AggregateReply_Aggregations_Aggregation_DateMessage): unknown {
    const obj: any = {};
    if (message.count !== undefined) {
      obj.count = Math.round(message.count);
    }
    if (message.type !== undefined) {
      obj.type = message.type;
    }
    if (message.median !== undefined) {
      obj.median = message.median;
    }
    if (message.mode !== undefined) {
      obj.mode = message.mode;
    }
    if (message.maximum !== undefined) {
      obj.maximum = message.maximum;
    }
    if (message.minimum !== undefined) {
      obj.minimum = message.minimum;
    }
    return obj;
  },

  create(
    base?: DeepPartial<AggregateReply_Aggregations_Aggregation_DateMessage>,
  ): AggregateReply_Aggregations_Aggregation_DateMessage {
    return AggregateReply_Aggregations_Aggregation_DateMessage.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<AggregateReply_Aggregations_Aggregation_DateMessage>,
  ): AggregateReply_Aggregations_Aggregation_DateMessage {
    const message = createBaseAggregateReply_Aggregations_Aggregation_DateMessage();
    message.count = object.count ?? undefined;
    message.type = object.type ?? undefined;
    message.median = object.median ?? undefined;
    message.mode = object.mode ?? undefined;
    message.maximum = object.maximum ?? undefined;
    message.minimum = object.minimum ?? undefined;
    return message;
  },
};

function createBaseAggregateReply_Aggregations_Aggregation_Reference(): AggregateReply_Aggregations_Aggregation_Reference {
  return { type: undefined, pointingTo: [] };
}

export const AggregateReply_Aggregations_Aggregation_Reference = {
  encode(
    message: AggregateReply_Aggregations_Aggregation_Reference,
    writer: _m0.Writer = _m0.Writer.create(),
  ): _m0.Writer {
    if (message.type !== undefined) {
      writer.uint32(10).string(message.type);
    }
    for (const v of message.pointingTo) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AggregateReply_Aggregations_Aggregation_Reference {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAggregateReply_Aggregations_Aggregation_Reference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.type = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.pointingTo.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AggregateReply_Aggregations_Aggregation_Reference {
    return {
      type: isSet(object.type) ? globalThis.String(object.type) : undefined,
      pointingTo: globalThis.Array.isArray(object?.pointingTo)
        ? object.pointingTo.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: AggregateReply_Aggregations_Aggregation_Reference): unknown {
    const obj: any = {};
    if (message.type !== undefined) {
      obj.type = message.type;
    }
    if (message.pointingTo?.length) {
      obj.pointingTo = message.pointingTo;
    }
    return obj;
  },

  create(
    base?: DeepPartial<AggregateReply_Aggregations_Aggregation_Reference>,
  ): AggregateReply_Aggregations_Aggregation_Reference {
    return AggregateReply_Aggregations_Aggregation_Reference.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<AggregateReply_Aggregations_Aggregation_Reference>,
  ): AggregateReply_Aggregations_Aggregation_Reference {
    const message = createBaseAggregateReply_Aggregations_Aggregation_Reference();
    message.type = object.type ?? undefined;
    message.pointingTo = object.pointingTo?.map((e) => e) || [];
    return message;
  },
};

function createBaseAggregateReply_Single(): AggregateReply_Single {
  return { objectsCount: undefined, aggregations: undefined };
}

export const AggregateReply_Single = {
  encode(message: AggregateReply_Single, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.objectsCount !== undefined) {
      writer.uint32(8).int64(message.objectsCount);
    }
    if (message.aggregations !== undefined) {
      AggregateReply_Aggregations.encode(message.aggregations, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AggregateReply_Single {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAggregateReply_Single();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.objectsCount = longToNumber(reader.int64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.aggregations = AggregateReply_Aggregations.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AggregateReply_Single {
    return {
      objectsCount: isSet(object.objectsCount) ? globalThis.Number(object.objectsCount) : undefined,
      aggregations: isSet(object.aggregations) ? AggregateReply_Aggregations.fromJSON(object.aggregations) : undefined,
    };
  },

  toJSON(message: AggregateReply_Single): unknown {
    const obj: any = {};
    if (message.objectsCount !== undefined) {
      obj.objectsCount = Math.round(message.objectsCount);
    }
    if (message.aggregations !== undefined) {
      obj.aggregations = AggregateReply_Aggregations.toJSON(message.aggregations);
    }
    return obj;
  },

  create(base?: DeepPartial<AggregateReply_Single>): AggregateReply_Single {
    return AggregateReply_Single.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AggregateReply_Single>): AggregateReply_Single {
    const message = createBaseAggregateReply_Single();
    message.objectsCount = object.objectsCount ?? undefined;
    message.aggregations = (object.aggregations !== undefined && object.aggregations !== null)
      ? AggregateReply_Aggregations.fromPartial(object.aggregations)
      : undefined;
    return message;
  },
};

function createBaseAggregateReply_Group(): AggregateReply_Group {
  return { objectsCount: undefined, aggregations: undefined, groupedBy: undefined };
}

export const AggregateReply_Group = {
  encode(message: AggregateReply_Group, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.objectsCount !== undefined) {
      writer.uint32(8).int64(message.objectsCount);
    }
    if (message.aggregations !== undefined) {
      AggregateReply_Aggregations.encode(message.aggregations, writer.uint32(18).fork()).ldelim();
    }
    if (message.groupedBy !== undefined) {
      AggregateReply_Group_GroupedBy.encode(message.groupedBy, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AggregateReply_Group {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAggregateReply_Group();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.objectsCount = longToNumber(reader.int64() as Long);
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.aggregations = AggregateReply_Aggregations.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.groupedBy = AggregateReply_Group_GroupedBy.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AggregateReply_Group {
    return {
      objectsCount: isSet(object.objectsCount) ? globalThis.Number(object.objectsCount) : undefined,
      aggregations: isSet(object.aggregations) ? AggregateReply_Aggregations.fromJSON(object.aggregations) : undefined,
      groupedBy: isSet(object.groupedBy) ? AggregateReply_Group_GroupedBy.fromJSON(object.groupedBy) : undefined,
    };
  },

  toJSON(message: AggregateReply_Group): unknown {
    const obj: any = {};
    if (message.objectsCount !== undefined) {
      obj.objectsCount = Math.round(message.objectsCount);
    }
    if (message.aggregations !== undefined) {
      obj.aggregations = AggregateReply_Aggregations.toJSON(message.aggregations);
    }
    if (message.groupedBy !== undefined) {
      obj.groupedBy = AggregateReply_Group_GroupedBy.toJSON(message.groupedBy);
    }
    return obj;
  },

  create(base?: DeepPartial<AggregateReply_Group>): AggregateReply_Group {
    return AggregateReply_Group.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AggregateReply_Group>): AggregateReply_Group {
    const message = createBaseAggregateReply_Group();
    message.objectsCount = object.objectsCount ?? undefined;
    message.aggregations = (object.aggregations !== undefined && object.aggregations !== null)
      ? AggregateReply_Aggregations.fromPartial(object.aggregations)
      : undefined;
    message.groupedBy = (object.groupedBy !== undefined && object.groupedBy !== null)
      ? AggregateReply_Group_GroupedBy.fromPartial(object.groupedBy)
      : undefined;
    return message;
  },
};

function createBaseAggregateReply_Group_GroupedBy(): AggregateReply_Group_GroupedBy {
  return {
    path: [],
    text: undefined,
    int: undefined,
    boolean: undefined,
    number: undefined,
    texts: undefined,
    ints: undefined,
    booleans: undefined,
    numbers: undefined,
    geo: undefined,
  };
}

export const AggregateReply_Group_GroupedBy = {
  encode(message: AggregateReply_Group_GroupedBy, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.path) {
      writer.uint32(10).string(v!);
    }
    if (message.text !== undefined) {
      writer.uint32(18).string(message.text);
    }
    if (message.int !== undefined) {
      writer.uint32(24).int64(message.int);
    }
    if (message.boolean !== undefined) {
      writer.uint32(32).bool(message.boolean);
    }
    if (message.number !== undefined) {
      writer.uint32(41).double(message.number);
    }
    if (message.texts !== undefined) {
      TextArray.encode(message.texts, writer.uint32(50).fork()).ldelim();
    }
    if (message.ints !== undefined) {
      IntArray.encode(message.ints, writer.uint32(58).fork()).ldelim();
    }
    if (message.booleans !== undefined) {
      BooleanArray.encode(message.booleans, writer.uint32(66).fork()).ldelim();
    }
    if (message.numbers !== undefined) {
      NumberArray.encode(message.numbers, writer.uint32(74).fork()).ldelim();
    }
    if (message.geo !== undefined) {
      GeoCoordinatesFilter.encode(message.geo, writer.uint32(82).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AggregateReply_Group_GroupedBy {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAggregateReply_Group_GroupedBy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.path.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.text = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.int = longToNumber(reader.int64() as Long);
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.boolean = reader.bool();
          continue;
        case 5:
          if (tag !== 41) {
            break;
          }

          message.number = reader.double();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.texts = TextArray.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.ints = IntArray.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.booleans = BooleanArray.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.numbers = NumberArray.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.geo = GeoCoordinatesFilter.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AggregateReply_Group_GroupedBy {
    return {
      path: globalThis.Array.isArray(object?.path) ? object.path.map((e: any) => globalThis.String(e)) : [],
      text: isSet(object.text) ? globalThis.String(object.text) : undefined,
      int: isSet(object.int) ? globalThis.Number(object.int) : undefined,
      boolean: isSet(object.boolean) ? globalThis.Boolean(object.boolean) : undefined,
      number: isSet(object.number) ? globalThis.Number(object.number) : undefined,
      texts: isSet(object.texts) ? TextArray.fromJSON(object.texts) : undefined,
      ints: isSet(object.ints) ? IntArray.fromJSON(object.ints) : undefined,
      booleans: isSet(object.booleans) ? BooleanArray.fromJSON(object.booleans) : undefined,
      numbers: isSet(object.numbers) ? NumberArray.fromJSON(object.numbers) : undefined,
      geo: isSet(object.geo) ? GeoCoordinatesFilter.fromJSON(object.geo) : undefined,
    };
  },

  toJSON(message: AggregateReply_Group_GroupedBy): unknown {
    const obj: any = {};
    if (message.path?.length) {
      obj.path = message.path;
    }
    if (message.text !== undefined) {
      obj.text = message.text;
    }
    if (message.int !== undefined) {
      obj.int = Math.round(message.int);
    }
    if (message.boolean !== undefined) {
      obj.boolean = message.boolean;
    }
    if (message.number !== undefined) {
      obj.number = message.number;
    }
    if (message.texts !== undefined) {
      obj.texts = TextArray.toJSON(message.texts);
    }
    if (message.ints !== undefined) {
      obj.ints = IntArray.toJSON(message.ints);
    }
    if (message.booleans !== undefined) {
      obj.booleans = BooleanArray.toJSON(message.booleans);
    }
    if (message.numbers !== undefined) {
      obj.numbers = NumberArray.toJSON(message.numbers);
    }
    if (message.geo !== undefined) {
      obj.geo = GeoCoordinatesFilter.toJSON(message.geo);
    }
    return obj;
  },

  create(base?: DeepPartial<AggregateReply_Group_GroupedBy>): AggregateReply_Group_GroupedBy {
    return AggregateReply_Group_GroupedBy.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AggregateReply_Group_GroupedBy>): AggregateReply_Group_GroupedBy {
    const message = createBaseAggregateReply_Group_GroupedBy();
    message.path = object.path?.map((e) => e) || [];
    message.text = object.text ?? undefined;
    message.int = object.int ?? undefined;
    message.boolean = object.boolean ?? undefined;
    message.number = object.number ?? undefined;
    message.texts = (object.texts !== undefined && object.texts !== null)
      ? TextArray.fromPartial(object.texts)
      : undefined;
    message.ints = (object.ints !== undefined && object.ints !== null) ? IntArray.fromPartial(object.ints) : undefined;
    message.booleans = (object.booleans !== undefined && object.booleans !== null)
      ? BooleanArray.fromPartial(object.booleans)
      : undefined;
    message.numbers = (object.numbers !== undefined && object.numbers !== null)
      ? NumberArray.fromPartial(object.numbers)
      : undefined;
    message.geo = (object.geo !== undefined && object.geo !== null)
      ? GeoCoordinatesFilter.fromPartial(object.geo)
      : undefined;
    return message;
  },
};

function createBaseAggregateReply_Grouped(): AggregateReply_Grouped {
  return { groups: [] };
}

export const AggregateReply_Grouped = {
  encode(message: AggregateReply_Grouped, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.groups) {
      AggregateReply_Group.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AggregateReply_Grouped {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAggregateReply_Grouped();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.groups.push(AggregateReply_Group.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AggregateReply_Grouped {
    return {
      groups: globalThis.Array.isArray(object?.groups)
        ? object.groups.map((e: any) => AggregateReply_Group.fromJSON(e))
        : [],
    };
  },

  toJSON(message: AggregateReply_Grouped): unknown {
    const obj: any = {};
    if (message.groups?.length) {
      obj.groups = message.groups.map((e) => AggregateReply_Group.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<AggregateReply_Grouped>): AggregateReply_Grouped {
    return AggregateReply_Grouped.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AggregateReply_Grouped>): AggregateReply_Grouped {
    const message = createBaseAggregateReply_Grouped();
    message.groups = object.groups?.map((e) => AggregateReply_Group.fromPartial(e)) || [];
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function longToNumber(long: Long): number {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

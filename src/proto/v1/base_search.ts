// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.176.0
//   protoc               v3.19.1
// source: v1/base_search.proto

/* eslint-disable */
import _m0 from "protobufjs/minimal.js";
import { Vectors } from "./base.js";

export const protobufPackage = "weaviate.v1";

export enum CombinationMethod {
  COMBINATION_METHOD_UNSPECIFIED = 0,
  COMBINATION_METHOD_TYPE_SUM = 1,
  COMBINATION_METHOD_TYPE_MIN = 2,
  COMBINATION_METHOD_TYPE_AVERAGE = 3,
  COMBINATION_METHOD_TYPE_RELATIVE_SCORE = 4,
  COMBINATION_METHOD_TYPE_MANUAL = 5,
  UNRECOGNIZED = -1,
}

export function combinationMethodFromJSON(object: any): CombinationMethod {
  switch (object) {
    case 0:
    case "COMBINATION_METHOD_UNSPECIFIED":
      return CombinationMethod.COMBINATION_METHOD_UNSPECIFIED;
    case 1:
    case "COMBINATION_METHOD_TYPE_SUM":
      return CombinationMethod.COMBINATION_METHOD_TYPE_SUM;
    case 2:
    case "COMBINATION_METHOD_TYPE_MIN":
      return CombinationMethod.COMBINATION_METHOD_TYPE_MIN;
    case 3:
    case "COMBINATION_METHOD_TYPE_AVERAGE":
      return CombinationMethod.COMBINATION_METHOD_TYPE_AVERAGE;
    case 4:
    case "COMBINATION_METHOD_TYPE_RELATIVE_SCORE":
      return CombinationMethod.COMBINATION_METHOD_TYPE_RELATIVE_SCORE;
    case 5:
    case "COMBINATION_METHOD_TYPE_MANUAL":
      return CombinationMethod.COMBINATION_METHOD_TYPE_MANUAL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CombinationMethod.UNRECOGNIZED;
  }
}

export function combinationMethodToJSON(object: CombinationMethod): string {
  switch (object) {
    case CombinationMethod.COMBINATION_METHOD_UNSPECIFIED:
      return "COMBINATION_METHOD_UNSPECIFIED";
    case CombinationMethod.COMBINATION_METHOD_TYPE_SUM:
      return "COMBINATION_METHOD_TYPE_SUM";
    case CombinationMethod.COMBINATION_METHOD_TYPE_MIN:
      return "COMBINATION_METHOD_TYPE_MIN";
    case CombinationMethod.COMBINATION_METHOD_TYPE_AVERAGE:
      return "COMBINATION_METHOD_TYPE_AVERAGE";
    case CombinationMethod.COMBINATION_METHOD_TYPE_RELATIVE_SCORE:
      return "COMBINATION_METHOD_TYPE_RELATIVE_SCORE";
    case CombinationMethod.COMBINATION_METHOD_TYPE_MANUAL:
      return "COMBINATION_METHOD_TYPE_MANUAL";
    case CombinationMethod.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface WeightsForTarget {
  target: string;
  weight: number;
}

export interface Targets {
  targetVectors: string[];
  combination: CombinationMethod;
  /**
   * deprecated in 1.26.2 - use weights_for_targets
   *
   * @deprecated
   */
  weights: { [key: string]: number };
  weightsForTargets: WeightsForTarget[];
}

export interface Targets_WeightsEntry {
  key: string;
  value: number;
}

export interface VectorForTarget {
  name: string;
  /**
   * deprecated in 1.29.0 - use vectors
   *
   * @deprecated
   */
  vectorBytes: Uint8Array;
  vectors: Vectors[];
}

export interface SearchOperatorOptions {
  operator: SearchOperatorOptions_Operator;
  minimumOrTokensMatch?: number | undefined;
}

export enum SearchOperatorOptions_Operator {
  OPERATOR_UNSPECIFIED = 0,
  OPERATOR_OR = 1,
  OPERATOR_AND = 2,
  UNRECOGNIZED = -1,
}

export function searchOperatorOptions_OperatorFromJSON(object: any): SearchOperatorOptions_Operator {
  switch (object) {
    case 0:
    case "OPERATOR_UNSPECIFIED":
      return SearchOperatorOptions_Operator.OPERATOR_UNSPECIFIED;
    case 1:
    case "OPERATOR_OR":
      return SearchOperatorOptions_Operator.OPERATOR_OR;
    case 2:
    case "OPERATOR_AND":
      return SearchOperatorOptions_Operator.OPERATOR_AND;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SearchOperatorOptions_Operator.UNRECOGNIZED;
  }
}

export function searchOperatorOptions_OperatorToJSON(object: SearchOperatorOptions_Operator): string {
  switch (object) {
    case SearchOperatorOptions_Operator.OPERATOR_UNSPECIFIED:
      return "OPERATOR_UNSPECIFIED";
    case SearchOperatorOptions_Operator.OPERATOR_OR:
      return "OPERATOR_OR";
    case SearchOperatorOptions_Operator.OPERATOR_AND:
      return "OPERATOR_AND";
    case SearchOperatorOptions_Operator.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Hybrid {
  query: string;
  properties: string[];
  /**
   * protolint:disable:next REPEATED_FIELD_NAMES_PLURALIZED
   *
   * @deprecated
   */
  vector: number[];
  alpha: number;
  fusionType: Hybrid_FusionType;
  /**
   * deprecated in 1.29.0 - use vectors
   *
   * @deprecated
   */
  vectorBytes: Uint8Array;
  /**
   * deprecated in 1.26 - use targets
   *
   * @deprecated
   */
  targetVectors: string[];
  /** targets in msg is ignored and should not be set for hybrid */
  nearText:
    | NearTextSearch
    | undefined;
  /** same as above. Use the target vector in the hybrid message */
  nearVector: NearVector | undefined;
  targets: Targets | undefined;
  bm25SearchOperator?: SearchOperatorOptions | undefined;
  vectorDistance?: number | undefined;
  vectors: Vectors[];
}

export enum Hybrid_FusionType {
  FUSION_TYPE_UNSPECIFIED = 0,
  FUSION_TYPE_RANKED = 1,
  FUSION_TYPE_RELATIVE_SCORE = 2,
  UNRECOGNIZED = -1,
}

export function hybrid_FusionTypeFromJSON(object: any): Hybrid_FusionType {
  switch (object) {
    case 0:
    case "FUSION_TYPE_UNSPECIFIED":
      return Hybrid_FusionType.FUSION_TYPE_UNSPECIFIED;
    case 1:
    case "FUSION_TYPE_RANKED":
      return Hybrid_FusionType.FUSION_TYPE_RANKED;
    case 2:
    case "FUSION_TYPE_RELATIVE_SCORE":
      return Hybrid_FusionType.FUSION_TYPE_RELATIVE_SCORE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Hybrid_FusionType.UNRECOGNIZED;
  }
}

export function hybrid_FusionTypeToJSON(object: Hybrid_FusionType): string {
  switch (object) {
    case Hybrid_FusionType.FUSION_TYPE_UNSPECIFIED:
      return "FUSION_TYPE_UNSPECIFIED";
    case Hybrid_FusionType.FUSION_TYPE_RANKED:
      return "FUSION_TYPE_RANKED";
    case Hybrid_FusionType.FUSION_TYPE_RELATIVE_SCORE:
      return "FUSION_TYPE_RELATIVE_SCORE";
    case Hybrid_FusionType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface NearVector {
  /**
   * protolint:disable:next REPEATED_FIELD_NAMES_PLURALIZED
   *
   * @deprecated
   */
  vector: number[];
  certainty?: number | undefined;
  distance?:
    | number
    | undefined;
  /**
   * deprecated in 1.29.0 - use vectors
   *
   * @deprecated
   */
  vectorBytes: Uint8Array;
  /**
   * deprecated in 1.26 - use targets
   *
   * @deprecated
   */
  targetVectors: string[];
  targets:
    | Targets
    | undefined;
  /**
   * deprecated in 1.26.2 - use vector_for_targets
   *
   * @deprecated
   */
  vectorPerTarget: { [key: string]: Uint8Array };
  vectorForTargets: VectorForTarget[];
  vectors: Vectors[];
}

export interface NearVector_VectorPerTargetEntry {
  key: string;
  value: Uint8Array;
}

export interface NearObject {
  id: string;
  certainty?: number | undefined;
  distance?:
    | number
    | undefined;
  /**
   * deprecated in 1.26 - use targets
   *
   * @deprecated
   */
  targetVectors: string[];
  targets: Targets | undefined;
}

export interface NearTextSearch {
  /** protolint:disable:next REPEATED_FIELD_NAMES_PLURALIZED */
  query: string[];
  certainty?: number | undefined;
  distance?: number | undefined;
  moveTo?: NearTextSearch_Move | undefined;
  moveAway?:
    | NearTextSearch_Move
    | undefined;
  /**
   * deprecated in 1.26 - use targets
   *
   * @deprecated
   */
  targetVectors: string[];
  targets: Targets | undefined;
}

export interface NearTextSearch_Move {
  force: number;
  concepts: string[];
  uuids: string[];
}

export interface NearImageSearch {
  image: string;
  certainty?: number | undefined;
  distance?:
    | number
    | undefined;
  /**
   * deprecated in 1.26 - use targets
   *
   * @deprecated
   */
  targetVectors: string[];
  targets: Targets | undefined;
}

export interface NearAudioSearch {
  audio: string;
  certainty?: number | undefined;
  distance?:
    | number
    | undefined;
  /**
   * deprecated in 1.26 - use targets
   *
   * @deprecated
   */
  targetVectors: string[];
  targets: Targets | undefined;
}

export interface NearVideoSearch {
  video: string;
  certainty?: number | undefined;
  distance?:
    | number
    | undefined;
  /**
   * deprecated in 1.26 - use targets
   *
   * @deprecated
   */
  targetVectors: string[];
  targets: Targets | undefined;
}

export interface NearDepthSearch {
  depth: string;
  certainty?: number | undefined;
  distance?:
    | number
    | undefined;
  /**
   * deprecated in 1.26 - use targets
   *
   * @deprecated
   */
  targetVectors: string[];
  targets: Targets | undefined;
}

export interface NearThermalSearch {
  thermal: string;
  certainty?: number | undefined;
  distance?:
    | number
    | undefined;
  /**
   * deprecated in 1.26 - use targets
   *
   * @deprecated
   */
  targetVectors: string[];
  targets: Targets | undefined;
}

export interface NearIMUSearch {
  imu: string;
  certainty?: number | undefined;
  distance?:
    | number
    | undefined;
  /**
   * deprecated in 1.26 - use targets
   *
   * @deprecated
   */
  targetVectors: string[];
  targets: Targets | undefined;
}

export interface BM25 {
  query: string;
  properties: string[];
  searchOperator?: SearchOperatorOptions | undefined;
}

function createBaseWeightsForTarget(): WeightsForTarget {
  return { target: "", weight: 0 };
}

export const WeightsForTarget = {
  encode(message: WeightsForTarget, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.target !== "") {
      writer.uint32(10).string(message.target);
    }
    if (message.weight !== 0) {
      writer.uint32(21).float(message.weight);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): WeightsForTarget {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWeightsForTarget();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.target = reader.string();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.weight = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WeightsForTarget {
    return {
      target: isSet(object.target) ? globalThis.String(object.target) : "",
      weight: isSet(object.weight) ? globalThis.Number(object.weight) : 0,
    };
  },

  toJSON(message: WeightsForTarget): unknown {
    const obj: any = {};
    if (message.target !== "") {
      obj.target = message.target;
    }
    if (message.weight !== 0) {
      obj.weight = message.weight;
    }
    return obj;
  },

  create(base?: DeepPartial<WeightsForTarget>): WeightsForTarget {
    return WeightsForTarget.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WeightsForTarget>): WeightsForTarget {
    const message = createBaseWeightsForTarget();
    message.target = object.target ?? "";
    message.weight = object.weight ?? 0;
    return message;
  },
};

function createBaseTargets(): Targets {
  return { targetVectors: [], combination: 0, weights: {}, weightsForTargets: [] };
}

export const Targets = {
  encode(message: Targets, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.targetVectors) {
      writer.uint32(10).string(v!);
    }
    if (message.combination !== 0) {
      writer.uint32(16).int32(message.combination);
    }
    Object.entries(message.weights).forEach(([key, value]) => {
      Targets_WeightsEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).ldelim();
    });
    for (const v of message.weightsForTargets) {
      WeightsForTarget.encode(v!, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Targets {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTargets();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.targetVectors.push(reader.string());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.combination = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = Targets_WeightsEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.weights[entry3.key] = entry3.value;
          }
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.weightsForTargets.push(WeightsForTarget.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Targets {
    return {
      targetVectors: globalThis.Array.isArray(object?.targetVectors)
        ? object.targetVectors.map((e: any) => globalThis.String(e))
        : [],
      combination: isSet(object.combination) ? combinationMethodFromJSON(object.combination) : 0,
      weights: isObject(object.weights)
        ? Object.entries(object.weights).reduce<{ [key: string]: number }>((acc, [key, value]) => {
          acc[key] = Number(value);
          return acc;
        }, {})
        : {},
      weightsForTargets: globalThis.Array.isArray(object?.weightsForTargets)
        ? object.weightsForTargets.map((e: any) => WeightsForTarget.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Targets): unknown {
    const obj: any = {};
    if (message.targetVectors?.length) {
      obj.targetVectors = message.targetVectors;
    }
    if (message.combination !== 0) {
      obj.combination = combinationMethodToJSON(message.combination);
    }
    if (message.weights) {
      const entries = Object.entries(message.weights);
      if (entries.length > 0) {
        obj.weights = {};
        entries.forEach(([k, v]) => {
          obj.weights[k] = v;
        });
      }
    }
    if (message.weightsForTargets?.length) {
      obj.weightsForTargets = message.weightsForTargets.map((e) => WeightsForTarget.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Targets>): Targets {
    return Targets.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Targets>): Targets {
    const message = createBaseTargets();
    message.targetVectors = object.targetVectors?.map((e) => e) || [];
    message.combination = object.combination ?? 0;
    message.weights = Object.entries(object.weights ?? {}).reduce<{ [key: string]: number }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.Number(value);
      }
      return acc;
    }, {});
    message.weightsForTargets = object.weightsForTargets?.map((e) => WeightsForTarget.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTargets_WeightsEntry(): Targets_WeightsEntry {
  return { key: "", value: 0 };
}

export const Targets_WeightsEntry = {
  encode(message: Targets_WeightsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== 0) {
      writer.uint32(21).float(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Targets_WeightsEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTargets_WeightsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.value = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Targets_WeightsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: Targets_WeightsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== 0) {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<Targets_WeightsEntry>): Targets_WeightsEntry {
    return Targets_WeightsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Targets_WeightsEntry>): Targets_WeightsEntry {
    const message = createBaseTargets_WeightsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseVectorForTarget(): VectorForTarget {
  return { name: "", vectorBytes: new Uint8Array(0), vectors: [] };
}

export const VectorForTarget = {
  encode(message: VectorForTarget, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.vectorBytes.length !== 0) {
      writer.uint32(18).bytes(message.vectorBytes);
    }
    for (const v of message.vectors) {
      Vectors.encode(v!, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): VectorForTarget {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVectorForTarget();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.vectorBytes = reader.bytes();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.vectors.push(Vectors.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VectorForTarget {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      vectorBytes: isSet(object.vectorBytes) ? bytesFromBase64(object.vectorBytes) : new Uint8Array(0),
      vectors: globalThis.Array.isArray(object?.vectors) ? object.vectors.map((e: any) => Vectors.fromJSON(e)) : [],
    };
  },

  toJSON(message: VectorForTarget): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.vectorBytes.length !== 0) {
      obj.vectorBytes = base64FromBytes(message.vectorBytes);
    }
    if (message.vectors?.length) {
      obj.vectors = message.vectors.map((e) => Vectors.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<VectorForTarget>): VectorForTarget {
    return VectorForTarget.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VectorForTarget>): VectorForTarget {
    const message = createBaseVectorForTarget();
    message.name = object.name ?? "";
    message.vectorBytes = object.vectorBytes ?? new Uint8Array(0);
    message.vectors = object.vectors?.map((e) => Vectors.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSearchOperatorOptions(): SearchOperatorOptions {
  return { operator: 0, minimumOrTokensMatch: undefined };
}

export const SearchOperatorOptions = {
  encode(message: SearchOperatorOptions, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.operator !== 0) {
      writer.uint32(8).int32(message.operator);
    }
    if (message.minimumOrTokensMatch !== undefined) {
      writer.uint32(16).int32(message.minimumOrTokensMatch);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SearchOperatorOptions {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchOperatorOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.operator = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.minimumOrTokensMatch = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchOperatorOptions {
    return {
      operator: isSet(object.operator) ? searchOperatorOptions_OperatorFromJSON(object.operator) : 0,
      minimumOrTokensMatch: isSet(object.minimumOrTokensMatch)
        ? globalThis.Number(object.minimumOrTokensMatch)
        : undefined,
    };
  },

  toJSON(message: SearchOperatorOptions): unknown {
    const obj: any = {};
    if (message.operator !== 0) {
      obj.operator = searchOperatorOptions_OperatorToJSON(message.operator);
    }
    if (message.minimumOrTokensMatch !== undefined) {
      obj.minimumOrTokensMatch = Math.round(message.minimumOrTokensMatch);
    }
    return obj;
  },

  create(base?: DeepPartial<SearchOperatorOptions>): SearchOperatorOptions {
    return SearchOperatorOptions.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SearchOperatorOptions>): SearchOperatorOptions {
    const message = createBaseSearchOperatorOptions();
    message.operator = object.operator ?? 0;
    message.minimumOrTokensMatch = object.minimumOrTokensMatch ?? undefined;
    return message;
  },
};

function createBaseHybrid(): Hybrid {
  return {
    query: "",
    properties: [],
    vector: [],
    alpha: 0,
    fusionType: 0,
    vectorBytes: new Uint8Array(0),
    targetVectors: [],
    nearText: undefined,
    nearVector: undefined,
    targets: undefined,
    bm25SearchOperator: undefined,
    vectorDistance: undefined,
    vectors: [],
  };
}

export const Hybrid = {
  encode(message: Hybrid, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.query !== "") {
      writer.uint32(10).string(message.query);
    }
    for (const v of message.properties) {
      writer.uint32(18).string(v!);
    }
    writer.uint32(26).fork();
    for (const v of message.vector) {
      writer.float(v);
    }
    writer.ldelim();
    if (message.alpha !== 0) {
      writer.uint32(37).float(message.alpha);
    }
    if (message.fusionType !== 0) {
      writer.uint32(40).int32(message.fusionType);
    }
    if (message.vectorBytes.length !== 0) {
      writer.uint32(50).bytes(message.vectorBytes);
    }
    for (const v of message.targetVectors) {
      writer.uint32(58).string(v!);
    }
    if (message.nearText !== undefined) {
      NearTextSearch.encode(message.nearText, writer.uint32(66).fork()).ldelim();
    }
    if (message.nearVector !== undefined) {
      NearVector.encode(message.nearVector, writer.uint32(74).fork()).ldelim();
    }
    if (message.targets !== undefined) {
      Targets.encode(message.targets, writer.uint32(82).fork()).ldelim();
    }
    if (message.bm25SearchOperator !== undefined) {
      SearchOperatorOptions.encode(message.bm25SearchOperator, writer.uint32(90).fork()).ldelim();
    }
    if (message.vectorDistance !== undefined) {
      writer.uint32(165).float(message.vectorDistance);
    }
    for (const v of message.vectors) {
      Vectors.encode(v!, writer.uint32(170).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Hybrid {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHybrid();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.query = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.properties.push(reader.string());
          continue;
        case 3:
          if (tag === 29) {
            message.vector.push(reader.float());

            continue;
          }

          if (tag === 26) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.vector.push(reader.float());
            }

            continue;
          }

          break;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.alpha = reader.float();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.fusionType = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.vectorBytes = reader.bytes();
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.targetVectors.push(reader.string());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.nearText = NearTextSearch.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.nearVector = NearVector.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.targets = Targets.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.bm25SearchOperator = SearchOperatorOptions.decode(reader, reader.uint32());
          continue;
        case 20:
          if (tag !== 165) {
            break;
          }

          message.vectorDistance = reader.float();
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.vectors.push(Vectors.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Hybrid {
    return {
      query: isSet(object.query) ? globalThis.String(object.query) : "",
      properties: globalThis.Array.isArray(object?.properties)
        ? object.properties.map((e: any) => globalThis.String(e))
        : [],
      vector: globalThis.Array.isArray(object?.vector) ? object.vector.map((e: any) => globalThis.Number(e)) : [],
      alpha: isSet(object.alpha) ? globalThis.Number(object.alpha) : 0,
      fusionType: isSet(object.fusionType) ? hybrid_FusionTypeFromJSON(object.fusionType) : 0,
      vectorBytes: isSet(object.vectorBytes) ? bytesFromBase64(object.vectorBytes) : new Uint8Array(0),
      targetVectors: globalThis.Array.isArray(object?.targetVectors)
        ? object.targetVectors.map((e: any) => globalThis.String(e))
        : [],
      nearText: isSet(object.nearText) ? NearTextSearch.fromJSON(object.nearText) : undefined,
      nearVector: isSet(object.nearVector) ? NearVector.fromJSON(object.nearVector) : undefined,
      targets: isSet(object.targets) ? Targets.fromJSON(object.targets) : undefined,
      bm25SearchOperator: isSet(object.bm25SearchOperator)
        ? SearchOperatorOptions.fromJSON(object.bm25SearchOperator)
        : undefined,
      vectorDistance: isSet(object.vectorDistance) ? globalThis.Number(object.vectorDistance) : undefined,
      vectors: globalThis.Array.isArray(object?.vectors) ? object.vectors.map((e: any) => Vectors.fromJSON(e)) : [],
    };
  },

  toJSON(message: Hybrid): unknown {
    const obj: any = {};
    if (message.query !== "") {
      obj.query = message.query;
    }
    if (message.properties?.length) {
      obj.properties = message.properties;
    }
    if (message.vector?.length) {
      obj.vector = message.vector;
    }
    if (message.alpha !== 0) {
      obj.alpha = message.alpha;
    }
    if (message.fusionType !== 0) {
      obj.fusionType = hybrid_FusionTypeToJSON(message.fusionType);
    }
    if (message.vectorBytes.length !== 0) {
      obj.vectorBytes = base64FromBytes(message.vectorBytes);
    }
    if (message.targetVectors?.length) {
      obj.targetVectors = message.targetVectors;
    }
    if (message.nearText !== undefined) {
      obj.nearText = NearTextSearch.toJSON(message.nearText);
    }
    if (message.nearVector !== undefined) {
      obj.nearVector = NearVector.toJSON(message.nearVector);
    }
    if (message.targets !== undefined) {
      obj.targets = Targets.toJSON(message.targets);
    }
    if (message.bm25SearchOperator !== undefined) {
      obj.bm25SearchOperator = SearchOperatorOptions.toJSON(message.bm25SearchOperator);
    }
    if (message.vectorDistance !== undefined) {
      obj.vectorDistance = message.vectorDistance;
    }
    if (message.vectors?.length) {
      obj.vectors = message.vectors.map((e) => Vectors.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Hybrid>): Hybrid {
    return Hybrid.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Hybrid>): Hybrid {
    const message = createBaseHybrid();
    message.query = object.query ?? "";
    message.properties = object.properties?.map((e) => e) || [];
    message.vector = object.vector?.map((e) => e) || [];
    message.alpha = object.alpha ?? 0;
    message.fusionType = object.fusionType ?? 0;
    message.vectorBytes = object.vectorBytes ?? new Uint8Array(0);
    message.targetVectors = object.targetVectors?.map((e) => e) || [];
    message.nearText = (object.nearText !== undefined && object.nearText !== null)
      ? NearTextSearch.fromPartial(object.nearText)
      : undefined;
    message.nearVector = (object.nearVector !== undefined && object.nearVector !== null)
      ? NearVector.fromPartial(object.nearVector)
      : undefined;
    message.targets = (object.targets !== undefined && object.targets !== null)
      ? Targets.fromPartial(object.targets)
      : undefined;
    message.bm25SearchOperator = (object.bm25SearchOperator !== undefined && object.bm25SearchOperator !== null)
      ? SearchOperatorOptions.fromPartial(object.bm25SearchOperator)
      : undefined;
    message.vectorDistance = object.vectorDistance ?? undefined;
    message.vectors = object.vectors?.map((e) => Vectors.fromPartial(e)) || [];
    return message;
  },
};

function createBaseNearVector(): NearVector {
  return {
    vector: [],
    certainty: undefined,
    distance: undefined,
    vectorBytes: new Uint8Array(0),
    targetVectors: [],
    targets: undefined,
    vectorPerTarget: {},
    vectorForTargets: [],
    vectors: [],
  };
}

export const NearVector = {
  encode(message: NearVector, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    writer.uint32(10).fork();
    for (const v of message.vector) {
      writer.float(v);
    }
    writer.ldelim();
    if (message.certainty !== undefined) {
      writer.uint32(17).double(message.certainty);
    }
    if (message.distance !== undefined) {
      writer.uint32(25).double(message.distance);
    }
    if (message.vectorBytes.length !== 0) {
      writer.uint32(34).bytes(message.vectorBytes);
    }
    for (const v of message.targetVectors) {
      writer.uint32(42).string(v!);
    }
    if (message.targets !== undefined) {
      Targets.encode(message.targets, writer.uint32(50).fork()).ldelim();
    }
    Object.entries(message.vectorPerTarget).forEach(([key, value]) => {
      NearVector_VectorPerTargetEntry.encode({ key: key as any, value }, writer.uint32(58).fork()).ldelim();
    });
    for (const v of message.vectorForTargets) {
      VectorForTarget.encode(v!, writer.uint32(66).fork()).ldelim();
    }
    for (const v of message.vectors) {
      Vectors.encode(v!, writer.uint32(74).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NearVector {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNearVector();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag === 13) {
            message.vector.push(reader.float());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.vector.push(reader.float());
            }

            continue;
          }

          break;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.certainty = reader.double();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.distance = reader.double();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.vectorBytes = reader.bytes();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.targetVectors.push(reader.string());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.targets = Targets.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          const entry7 = NearVector_VectorPerTargetEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.vectorPerTarget[entry7.key] = entry7.value;
          }
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.vectorForTargets.push(VectorForTarget.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.vectors.push(Vectors.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NearVector {
    return {
      vector: globalThis.Array.isArray(object?.vector) ? object.vector.map((e: any) => globalThis.Number(e)) : [],
      certainty: isSet(object.certainty) ? globalThis.Number(object.certainty) : undefined,
      distance: isSet(object.distance) ? globalThis.Number(object.distance) : undefined,
      vectorBytes: isSet(object.vectorBytes) ? bytesFromBase64(object.vectorBytes) : new Uint8Array(0),
      targetVectors: globalThis.Array.isArray(object?.targetVectors)
        ? object.targetVectors.map((e: any) => globalThis.String(e))
        : [],
      targets: isSet(object.targets) ? Targets.fromJSON(object.targets) : undefined,
      vectorPerTarget: isObject(object.vectorPerTarget)
        ? Object.entries(object.vectorPerTarget).reduce<{ [key: string]: Uint8Array }>((acc, [key, value]) => {
          acc[key] = bytesFromBase64(value as string);
          return acc;
        }, {})
        : {},
      vectorForTargets: globalThis.Array.isArray(object?.vectorForTargets)
        ? object.vectorForTargets.map((e: any) => VectorForTarget.fromJSON(e))
        : [],
      vectors: globalThis.Array.isArray(object?.vectors) ? object.vectors.map((e: any) => Vectors.fromJSON(e)) : [],
    };
  },

  toJSON(message: NearVector): unknown {
    const obj: any = {};
    if (message.vector?.length) {
      obj.vector = message.vector;
    }
    if (message.certainty !== undefined) {
      obj.certainty = message.certainty;
    }
    if (message.distance !== undefined) {
      obj.distance = message.distance;
    }
    if (message.vectorBytes.length !== 0) {
      obj.vectorBytes = base64FromBytes(message.vectorBytes);
    }
    if (message.targetVectors?.length) {
      obj.targetVectors = message.targetVectors;
    }
    if (message.targets !== undefined) {
      obj.targets = Targets.toJSON(message.targets);
    }
    if (message.vectorPerTarget) {
      const entries = Object.entries(message.vectorPerTarget);
      if (entries.length > 0) {
        obj.vectorPerTarget = {};
        entries.forEach(([k, v]) => {
          obj.vectorPerTarget[k] = base64FromBytes(v);
        });
      }
    }
    if (message.vectorForTargets?.length) {
      obj.vectorForTargets = message.vectorForTargets.map((e) => VectorForTarget.toJSON(e));
    }
    if (message.vectors?.length) {
      obj.vectors = message.vectors.map((e) => Vectors.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<NearVector>): NearVector {
    return NearVector.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NearVector>): NearVector {
    const message = createBaseNearVector();
    message.vector = object.vector?.map((e) => e) || [];
    message.certainty = object.certainty ?? undefined;
    message.distance = object.distance ?? undefined;
    message.vectorBytes = object.vectorBytes ?? new Uint8Array(0);
    message.targetVectors = object.targetVectors?.map((e) => e) || [];
    message.targets = (object.targets !== undefined && object.targets !== null)
      ? Targets.fromPartial(object.targets)
      : undefined;
    message.vectorPerTarget = Object.entries(object.vectorPerTarget ?? {}).reduce<{ [key: string]: Uint8Array }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = value;
        }
        return acc;
      },
      {},
    );
    message.vectorForTargets = object.vectorForTargets?.map((e) => VectorForTarget.fromPartial(e)) || [];
    message.vectors = object.vectors?.map((e) => Vectors.fromPartial(e)) || [];
    return message;
  },
};

function createBaseNearVector_VectorPerTargetEntry(): NearVector_VectorPerTargetEntry {
  return { key: "", value: new Uint8Array(0) };
}

export const NearVector_VectorPerTargetEntry = {
  encode(message: NearVector_VectorPerTargetEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value.length !== 0) {
      writer.uint32(18).bytes(message.value);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NearVector_VectorPerTargetEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNearVector_VectorPerTargetEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.bytes();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NearVector_VectorPerTargetEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? bytesFromBase64(object.value) : new Uint8Array(0),
    };
  },

  toJSON(message: NearVector_VectorPerTargetEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value.length !== 0) {
      obj.value = base64FromBytes(message.value);
    }
    return obj;
  },

  create(base?: DeepPartial<NearVector_VectorPerTargetEntry>): NearVector_VectorPerTargetEntry {
    return NearVector_VectorPerTargetEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NearVector_VectorPerTargetEntry>): NearVector_VectorPerTargetEntry {
    const message = createBaseNearVector_VectorPerTargetEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? new Uint8Array(0);
    return message;
  },
};

function createBaseNearObject(): NearObject {
  return { id: "", certainty: undefined, distance: undefined, targetVectors: [], targets: undefined };
}

export const NearObject = {
  encode(message: NearObject, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.certainty !== undefined) {
      writer.uint32(17).double(message.certainty);
    }
    if (message.distance !== undefined) {
      writer.uint32(25).double(message.distance);
    }
    for (const v of message.targetVectors) {
      writer.uint32(34).string(v!);
    }
    if (message.targets !== undefined) {
      Targets.encode(message.targets, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NearObject {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNearObject();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.certainty = reader.double();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.distance = reader.double();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.targetVectors.push(reader.string());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.targets = Targets.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NearObject {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      certainty: isSet(object.certainty) ? globalThis.Number(object.certainty) : undefined,
      distance: isSet(object.distance) ? globalThis.Number(object.distance) : undefined,
      targetVectors: globalThis.Array.isArray(object?.targetVectors)
        ? object.targetVectors.map((e: any) => globalThis.String(e))
        : [],
      targets: isSet(object.targets) ? Targets.fromJSON(object.targets) : undefined,
    };
  },

  toJSON(message: NearObject): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.certainty !== undefined) {
      obj.certainty = message.certainty;
    }
    if (message.distance !== undefined) {
      obj.distance = message.distance;
    }
    if (message.targetVectors?.length) {
      obj.targetVectors = message.targetVectors;
    }
    if (message.targets !== undefined) {
      obj.targets = Targets.toJSON(message.targets);
    }
    return obj;
  },

  create(base?: DeepPartial<NearObject>): NearObject {
    return NearObject.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NearObject>): NearObject {
    const message = createBaseNearObject();
    message.id = object.id ?? "";
    message.certainty = object.certainty ?? undefined;
    message.distance = object.distance ?? undefined;
    message.targetVectors = object.targetVectors?.map((e) => e) || [];
    message.targets = (object.targets !== undefined && object.targets !== null)
      ? Targets.fromPartial(object.targets)
      : undefined;
    return message;
  },
};

function createBaseNearTextSearch(): NearTextSearch {
  return {
    query: [],
    certainty: undefined,
    distance: undefined,
    moveTo: undefined,
    moveAway: undefined,
    targetVectors: [],
    targets: undefined,
  };
}

export const NearTextSearch = {
  encode(message: NearTextSearch, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.query) {
      writer.uint32(10).string(v!);
    }
    if (message.certainty !== undefined) {
      writer.uint32(17).double(message.certainty);
    }
    if (message.distance !== undefined) {
      writer.uint32(25).double(message.distance);
    }
    if (message.moveTo !== undefined) {
      NearTextSearch_Move.encode(message.moveTo, writer.uint32(34).fork()).ldelim();
    }
    if (message.moveAway !== undefined) {
      NearTextSearch_Move.encode(message.moveAway, writer.uint32(42).fork()).ldelim();
    }
    for (const v of message.targetVectors) {
      writer.uint32(50).string(v!);
    }
    if (message.targets !== undefined) {
      Targets.encode(message.targets, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NearTextSearch {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNearTextSearch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.query.push(reader.string());
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.certainty = reader.double();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.distance = reader.double();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.moveTo = NearTextSearch_Move.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.moveAway = NearTextSearch_Move.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.targetVectors.push(reader.string());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.targets = Targets.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NearTextSearch {
    return {
      query: globalThis.Array.isArray(object?.query) ? object.query.map((e: any) => globalThis.String(e)) : [],
      certainty: isSet(object.certainty) ? globalThis.Number(object.certainty) : undefined,
      distance: isSet(object.distance) ? globalThis.Number(object.distance) : undefined,
      moveTo: isSet(object.moveTo) ? NearTextSearch_Move.fromJSON(object.moveTo) : undefined,
      moveAway: isSet(object.moveAway) ? NearTextSearch_Move.fromJSON(object.moveAway) : undefined,
      targetVectors: globalThis.Array.isArray(object?.targetVectors)
        ? object.targetVectors.map((e: any) => globalThis.String(e))
        : [],
      targets: isSet(object.targets) ? Targets.fromJSON(object.targets) : undefined,
    };
  },

  toJSON(message: NearTextSearch): unknown {
    const obj: any = {};
    if (message.query?.length) {
      obj.query = message.query;
    }
    if (message.certainty !== undefined) {
      obj.certainty = message.certainty;
    }
    if (message.distance !== undefined) {
      obj.distance = message.distance;
    }
    if (message.moveTo !== undefined) {
      obj.moveTo = NearTextSearch_Move.toJSON(message.moveTo);
    }
    if (message.moveAway !== undefined) {
      obj.moveAway = NearTextSearch_Move.toJSON(message.moveAway);
    }
    if (message.targetVectors?.length) {
      obj.targetVectors = message.targetVectors;
    }
    if (message.targets !== undefined) {
      obj.targets = Targets.toJSON(message.targets);
    }
    return obj;
  },

  create(base?: DeepPartial<NearTextSearch>): NearTextSearch {
    return NearTextSearch.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NearTextSearch>): NearTextSearch {
    const message = createBaseNearTextSearch();
    message.query = object.query?.map((e) => e) || [];
    message.certainty = object.certainty ?? undefined;
    message.distance = object.distance ?? undefined;
    message.moveTo = (object.moveTo !== undefined && object.moveTo !== null)
      ? NearTextSearch_Move.fromPartial(object.moveTo)
      : undefined;
    message.moveAway = (object.moveAway !== undefined && object.moveAway !== null)
      ? NearTextSearch_Move.fromPartial(object.moveAway)
      : undefined;
    message.targetVectors = object.targetVectors?.map((e) => e) || [];
    message.targets = (object.targets !== undefined && object.targets !== null)
      ? Targets.fromPartial(object.targets)
      : undefined;
    return message;
  },
};

function createBaseNearTextSearch_Move(): NearTextSearch_Move {
  return { force: 0, concepts: [], uuids: [] };
}

export const NearTextSearch_Move = {
  encode(message: NearTextSearch_Move, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.force !== 0) {
      writer.uint32(13).float(message.force);
    }
    for (const v of message.concepts) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.uuids) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NearTextSearch_Move {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNearTextSearch_Move();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.force = reader.float();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.concepts.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.uuids.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NearTextSearch_Move {
    return {
      force: isSet(object.force) ? globalThis.Number(object.force) : 0,
      concepts: globalThis.Array.isArray(object?.concepts) ? object.concepts.map((e: any) => globalThis.String(e)) : [],
      uuids: globalThis.Array.isArray(object?.uuids) ? object.uuids.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: NearTextSearch_Move): unknown {
    const obj: any = {};
    if (message.force !== 0) {
      obj.force = message.force;
    }
    if (message.concepts?.length) {
      obj.concepts = message.concepts;
    }
    if (message.uuids?.length) {
      obj.uuids = message.uuids;
    }
    return obj;
  },

  create(base?: DeepPartial<NearTextSearch_Move>): NearTextSearch_Move {
    return NearTextSearch_Move.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NearTextSearch_Move>): NearTextSearch_Move {
    const message = createBaseNearTextSearch_Move();
    message.force = object.force ?? 0;
    message.concepts = object.concepts?.map((e) => e) || [];
    message.uuids = object.uuids?.map((e) => e) || [];
    return message;
  },
};

function createBaseNearImageSearch(): NearImageSearch {
  return { image: "", certainty: undefined, distance: undefined, targetVectors: [], targets: undefined };
}

export const NearImageSearch = {
  encode(message: NearImageSearch, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.image !== "") {
      writer.uint32(10).string(message.image);
    }
    if (message.certainty !== undefined) {
      writer.uint32(17).double(message.certainty);
    }
    if (message.distance !== undefined) {
      writer.uint32(25).double(message.distance);
    }
    for (const v of message.targetVectors) {
      writer.uint32(34).string(v!);
    }
    if (message.targets !== undefined) {
      Targets.encode(message.targets, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NearImageSearch {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNearImageSearch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.image = reader.string();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.certainty = reader.double();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.distance = reader.double();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.targetVectors.push(reader.string());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.targets = Targets.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NearImageSearch {
    return {
      image: isSet(object.image) ? globalThis.String(object.image) : "",
      certainty: isSet(object.certainty) ? globalThis.Number(object.certainty) : undefined,
      distance: isSet(object.distance) ? globalThis.Number(object.distance) : undefined,
      targetVectors: globalThis.Array.isArray(object?.targetVectors)
        ? object.targetVectors.map((e: any) => globalThis.String(e))
        : [],
      targets: isSet(object.targets) ? Targets.fromJSON(object.targets) : undefined,
    };
  },

  toJSON(message: NearImageSearch): unknown {
    const obj: any = {};
    if (message.image !== "") {
      obj.image = message.image;
    }
    if (message.certainty !== undefined) {
      obj.certainty = message.certainty;
    }
    if (message.distance !== undefined) {
      obj.distance = message.distance;
    }
    if (message.targetVectors?.length) {
      obj.targetVectors = message.targetVectors;
    }
    if (message.targets !== undefined) {
      obj.targets = Targets.toJSON(message.targets);
    }
    return obj;
  },

  create(base?: DeepPartial<NearImageSearch>): NearImageSearch {
    return NearImageSearch.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NearImageSearch>): NearImageSearch {
    const message = createBaseNearImageSearch();
    message.image = object.image ?? "";
    message.certainty = object.certainty ?? undefined;
    message.distance = object.distance ?? undefined;
    message.targetVectors = object.targetVectors?.map((e) => e) || [];
    message.targets = (object.targets !== undefined && object.targets !== null)
      ? Targets.fromPartial(object.targets)
      : undefined;
    return message;
  },
};

function createBaseNearAudioSearch(): NearAudioSearch {
  return { audio: "", certainty: undefined, distance: undefined, targetVectors: [], targets: undefined };
}

export const NearAudioSearch = {
  encode(message: NearAudioSearch, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.audio !== "") {
      writer.uint32(10).string(message.audio);
    }
    if (message.certainty !== undefined) {
      writer.uint32(17).double(message.certainty);
    }
    if (message.distance !== undefined) {
      writer.uint32(25).double(message.distance);
    }
    for (const v of message.targetVectors) {
      writer.uint32(34).string(v!);
    }
    if (message.targets !== undefined) {
      Targets.encode(message.targets, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NearAudioSearch {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNearAudioSearch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.audio = reader.string();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.certainty = reader.double();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.distance = reader.double();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.targetVectors.push(reader.string());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.targets = Targets.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NearAudioSearch {
    return {
      audio: isSet(object.audio) ? globalThis.String(object.audio) : "",
      certainty: isSet(object.certainty) ? globalThis.Number(object.certainty) : undefined,
      distance: isSet(object.distance) ? globalThis.Number(object.distance) : undefined,
      targetVectors: globalThis.Array.isArray(object?.targetVectors)
        ? object.targetVectors.map((e: any) => globalThis.String(e))
        : [],
      targets: isSet(object.targets) ? Targets.fromJSON(object.targets) : undefined,
    };
  },

  toJSON(message: NearAudioSearch): unknown {
    const obj: any = {};
    if (message.audio !== "") {
      obj.audio = message.audio;
    }
    if (message.certainty !== undefined) {
      obj.certainty = message.certainty;
    }
    if (message.distance !== undefined) {
      obj.distance = message.distance;
    }
    if (message.targetVectors?.length) {
      obj.targetVectors = message.targetVectors;
    }
    if (message.targets !== undefined) {
      obj.targets = Targets.toJSON(message.targets);
    }
    return obj;
  },

  create(base?: DeepPartial<NearAudioSearch>): NearAudioSearch {
    return NearAudioSearch.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NearAudioSearch>): NearAudioSearch {
    const message = createBaseNearAudioSearch();
    message.audio = object.audio ?? "";
    message.certainty = object.certainty ?? undefined;
    message.distance = object.distance ?? undefined;
    message.targetVectors = object.targetVectors?.map((e) => e) || [];
    message.targets = (object.targets !== undefined && object.targets !== null)
      ? Targets.fromPartial(object.targets)
      : undefined;
    return message;
  },
};

function createBaseNearVideoSearch(): NearVideoSearch {
  return { video: "", certainty: undefined, distance: undefined, targetVectors: [], targets: undefined };
}

export const NearVideoSearch = {
  encode(message: NearVideoSearch, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.video !== "") {
      writer.uint32(10).string(message.video);
    }
    if (message.certainty !== undefined) {
      writer.uint32(17).double(message.certainty);
    }
    if (message.distance !== undefined) {
      writer.uint32(25).double(message.distance);
    }
    for (const v of message.targetVectors) {
      writer.uint32(34).string(v!);
    }
    if (message.targets !== undefined) {
      Targets.encode(message.targets, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NearVideoSearch {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNearVideoSearch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.video = reader.string();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.certainty = reader.double();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.distance = reader.double();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.targetVectors.push(reader.string());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.targets = Targets.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NearVideoSearch {
    return {
      video: isSet(object.video) ? globalThis.String(object.video) : "",
      certainty: isSet(object.certainty) ? globalThis.Number(object.certainty) : undefined,
      distance: isSet(object.distance) ? globalThis.Number(object.distance) : undefined,
      targetVectors: globalThis.Array.isArray(object?.targetVectors)
        ? object.targetVectors.map((e: any) => globalThis.String(e))
        : [],
      targets: isSet(object.targets) ? Targets.fromJSON(object.targets) : undefined,
    };
  },

  toJSON(message: NearVideoSearch): unknown {
    const obj: any = {};
    if (message.video !== "") {
      obj.video = message.video;
    }
    if (message.certainty !== undefined) {
      obj.certainty = message.certainty;
    }
    if (message.distance !== undefined) {
      obj.distance = message.distance;
    }
    if (message.targetVectors?.length) {
      obj.targetVectors = message.targetVectors;
    }
    if (message.targets !== undefined) {
      obj.targets = Targets.toJSON(message.targets);
    }
    return obj;
  },

  create(base?: DeepPartial<NearVideoSearch>): NearVideoSearch {
    return NearVideoSearch.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NearVideoSearch>): NearVideoSearch {
    const message = createBaseNearVideoSearch();
    message.video = object.video ?? "";
    message.certainty = object.certainty ?? undefined;
    message.distance = object.distance ?? undefined;
    message.targetVectors = object.targetVectors?.map((e) => e) || [];
    message.targets = (object.targets !== undefined && object.targets !== null)
      ? Targets.fromPartial(object.targets)
      : undefined;
    return message;
  },
};

function createBaseNearDepthSearch(): NearDepthSearch {
  return { depth: "", certainty: undefined, distance: undefined, targetVectors: [], targets: undefined };
}

export const NearDepthSearch = {
  encode(message: NearDepthSearch, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.depth !== "") {
      writer.uint32(10).string(message.depth);
    }
    if (message.certainty !== undefined) {
      writer.uint32(17).double(message.certainty);
    }
    if (message.distance !== undefined) {
      writer.uint32(25).double(message.distance);
    }
    for (const v of message.targetVectors) {
      writer.uint32(34).string(v!);
    }
    if (message.targets !== undefined) {
      Targets.encode(message.targets, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NearDepthSearch {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNearDepthSearch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.depth = reader.string();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.certainty = reader.double();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.distance = reader.double();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.targetVectors.push(reader.string());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.targets = Targets.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NearDepthSearch {
    return {
      depth: isSet(object.depth) ? globalThis.String(object.depth) : "",
      certainty: isSet(object.certainty) ? globalThis.Number(object.certainty) : undefined,
      distance: isSet(object.distance) ? globalThis.Number(object.distance) : undefined,
      targetVectors: globalThis.Array.isArray(object?.targetVectors)
        ? object.targetVectors.map((e: any) => globalThis.String(e))
        : [],
      targets: isSet(object.targets) ? Targets.fromJSON(object.targets) : undefined,
    };
  },

  toJSON(message: NearDepthSearch): unknown {
    const obj: any = {};
    if (message.depth !== "") {
      obj.depth = message.depth;
    }
    if (message.certainty !== undefined) {
      obj.certainty = message.certainty;
    }
    if (message.distance !== undefined) {
      obj.distance = message.distance;
    }
    if (message.targetVectors?.length) {
      obj.targetVectors = message.targetVectors;
    }
    if (message.targets !== undefined) {
      obj.targets = Targets.toJSON(message.targets);
    }
    return obj;
  },

  create(base?: DeepPartial<NearDepthSearch>): NearDepthSearch {
    return NearDepthSearch.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NearDepthSearch>): NearDepthSearch {
    const message = createBaseNearDepthSearch();
    message.depth = object.depth ?? "";
    message.certainty = object.certainty ?? undefined;
    message.distance = object.distance ?? undefined;
    message.targetVectors = object.targetVectors?.map((e) => e) || [];
    message.targets = (object.targets !== undefined && object.targets !== null)
      ? Targets.fromPartial(object.targets)
      : undefined;
    return message;
  },
};

function createBaseNearThermalSearch(): NearThermalSearch {
  return { thermal: "", certainty: undefined, distance: undefined, targetVectors: [], targets: undefined };
}

export const NearThermalSearch = {
  encode(message: NearThermalSearch, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.thermal !== "") {
      writer.uint32(10).string(message.thermal);
    }
    if (message.certainty !== undefined) {
      writer.uint32(17).double(message.certainty);
    }
    if (message.distance !== undefined) {
      writer.uint32(25).double(message.distance);
    }
    for (const v of message.targetVectors) {
      writer.uint32(34).string(v!);
    }
    if (message.targets !== undefined) {
      Targets.encode(message.targets, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NearThermalSearch {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNearThermalSearch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.thermal = reader.string();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.certainty = reader.double();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.distance = reader.double();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.targetVectors.push(reader.string());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.targets = Targets.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NearThermalSearch {
    return {
      thermal: isSet(object.thermal) ? globalThis.String(object.thermal) : "",
      certainty: isSet(object.certainty) ? globalThis.Number(object.certainty) : undefined,
      distance: isSet(object.distance) ? globalThis.Number(object.distance) : undefined,
      targetVectors: globalThis.Array.isArray(object?.targetVectors)
        ? object.targetVectors.map((e: any) => globalThis.String(e))
        : [],
      targets: isSet(object.targets) ? Targets.fromJSON(object.targets) : undefined,
    };
  },

  toJSON(message: NearThermalSearch): unknown {
    const obj: any = {};
    if (message.thermal !== "") {
      obj.thermal = message.thermal;
    }
    if (message.certainty !== undefined) {
      obj.certainty = message.certainty;
    }
    if (message.distance !== undefined) {
      obj.distance = message.distance;
    }
    if (message.targetVectors?.length) {
      obj.targetVectors = message.targetVectors;
    }
    if (message.targets !== undefined) {
      obj.targets = Targets.toJSON(message.targets);
    }
    return obj;
  },

  create(base?: DeepPartial<NearThermalSearch>): NearThermalSearch {
    return NearThermalSearch.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NearThermalSearch>): NearThermalSearch {
    const message = createBaseNearThermalSearch();
    message.thermal = object.thermal ?? "";
    message.certainty = object.certainty ?? undefined;
    message.distance = object.distance ?? undefined;
    message.targetVectors = object.targetVectors?.map((e) => e) || [];
    message.targets = (object.targets !== undefined && object.targets !== null)
      ? Targets.fromPartial(object.targets)
      : undefined;
    return message;
  },
};

function createBaseNearIMUSearch(): NearIMUSearch {
  return { imu: "", certainty: undefined, distance: undefined, targetVectors: [], targets: undefined };
}

export const NearIMUSearch = {
  encode(message: NearIMUSearch, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.imu !== "") {
      writer.uint32(10).string(message.imu);
    }
    if (message.certainty !== undefined) {
      writer.uint32(17).double(message.certainty);
    }
    if (message.distance !== undefined) {
      writer.uint32(25).double(message.distance);
    }
    for (const v of message.targetVectors) {
      writer.uint32(34).string(v!);
    }
    if (message.targets !== undefined) {
      Targets.encode(message.targets, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): NearIMUSearch {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNearIMUSearch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.imu = reader.string();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.certainty = reader.double();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.distance = reader.double();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.targetVectors.push(reader.string());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.targets = Targets.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NearIMUSearch {
    return {
      imu: isSet(object.imu) ? globalThis.String(object.imu) : "",
      certainty: isSet(object.certainty) ? globalThis.Number(object.certainty) : undefined,
      distance: isSet(object.distance) ? globalThis.Number(object.distance) : undefined,
      targetVectors: globalThis.Array.isArray(object?.targetVectors)
        ? object.targetVectors.map((e: any) => globalThis.String(e))
        : [],
      targets: isSet(object.targets) ? Targets.fromJSON(object.targets) : undefined,
    };
  },

  toJSON(message: NearIMUSearch): unknown {
    const obj: any = {};
    if (message.imu !== "") {
      obj.imu = message.imu;
    }
    if (message.certainty !== undefined) {
      obj.certainty = message.certainty;
    }
    if (message.distance !== undefined) {
      obj.distance = message.distance;
    }
    if (message.targetVectors?.length) {
      obj.targetVectors = message.targetVectors;
    }
    if (message.targets !== undefined) {
      obj.targets = Targets.toJSON(message.targets);
    }
    return obj;
  },

  create(base?: DeepPartial<NearIMUSearch>): NearIMUSearch {
    return NearIMUSearch.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<NearIMUSearch>): NearIMUSearch {
    const message = createBaseNearIMUSearch();
    message.imu = object.imu ?? "";
    message.certainty = object.certainty ?? undefined;
    message.distance = object.distance ?? undefined;
    message.targetVectors = object.targetVectors?.map((e) => e) || [];
    message.targets = (object.targets !== undefined && object.targets !== null)
      ? Targets.fromPartial(object.targets)
      : undefined;
    return message;
  },
};

function createBaseBM25(): BM25 {
  return { query: "", properties: [], searchOperator: undefined };
}

export const BM25 = {
  encode(message: BM25, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.query !== "") {
      writer.uint32(10).string(message.query);
    }
    for (const v of message.properties) {
      writer.uint32(18).string(v!);
    }
    if (message.searchOperator !== undefined) {
      SearchOperatorOptions.encode(message.searchOperator, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): BM25 {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBM25();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.query = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.properties.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.searchOperator = SearchOperatorOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BM25 {
    return {
      query: isSet(object.query) ? globalThis.String(object.query) : "",
      properties: globalThis.Array.isArray(object?.properties)
        ? object.properties.map((e: any) => globalThis.String(e))
        : [],
      searchOperator: isSet(object.searchOperator) ? SearchOperatorOptions.fromJSON(object.searchOperator) : undefined,
    };
  },

  toJSON(message: BM25): unknown {
    const obj: any = {};
    if (message.query !== "") {
      obj.query = message.query;
    }
    if (message.properties?.length) {
      obj.properties = message.properties;
    }
    if (message.searchOperator !== undefined) {
      obj.searchOperator = SearchOperatorOptions.toJSON(message.searchOperator);
    }
    return obj;
  },

  create(base?: DeepPartial<BM25>): BM25 {
    return BM25.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BM25>): BM25 {
    const message = createBaseBM25();
    message.query = object.query ?? "";
    message.properties = object.properties?.map((e) => e) || [];
    message.searchOperator = (object.searchOperator !== undefined && object.searchOperator !== null)
      ? SearchOperatorOptions.fromPartial(object.searchOperator)
      : undefined;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
